RNA_wrap.c

[ Module : RNA, Package : RNA ]


1.  Folding Routines
====================

1.1.  Minimum free Energy Folding
---------------------------------

fold(sequence,structure);
        [ returns float  ]
        calculate mfe-structure of sequence 

energy_of_struct(string,structure);
        [ returns float  ]
        calculate energy of string on structure 

free_arrays();
        [ returns void  ]
        free arrays for mfe folding 

initialize_fold(length);
        [ returns void  ]
        allocate arrays for folding 

update_fold_params();
        [ returns void  ]
        recalculate parameters 

1.2.  Partition function Folding
--------------------------------

pf_fold(sequence,structure);
        [ returns float  ]
        calculate partition function and base pair probabilities 

init_pf_fold(length);
        [ returns void  ]
        allocate space for pf_fold() 

free_pf_arrays();
        [ returns void  ]
        free arrays from pf_fold() 

update_pf_params(length);
        [ returns void  ]
        recalculate energy parameters 

bppm_symbol(x);
        [ returns char  ]
        string representation of structure 

1.3.  Inverse Folding
---------------------

$symbolset
        [ Global : char * symbolset ]
        alphabet default is "AUGC" 

inverse_fold(start,target);
        [ returns float  ]
        find sequences with predifined structure. the found sequence is
        written to start, return value is energy_of_struct(start, target)
        - fold(start, structure), i.e. 0. if search was successful; 

inverse_pf_fold(start,target);
        [ returns float  ]
        inverse folding maximising the frequency of target in the ensemble
        of structures, final sequence is written to start, returns energy_of_struct(start,
        target) - part_func(start, structure) 

$final_cost
        [ Global : float final_cost ]
        when to stop inverse_pf_fold() 

$give_up
        [ Global : int give_up ]
        default 0: try to minimize structure distance even if no exact solution
        can be found 

1.4.  Global Variables to Modify Folding
----------------------------------------

$pr
        [ Global : float * pr ]
        base pairing prob. matrix 

$noGU
        [ Global : int noGU ]
        GU not allowed at all 

$no_closingGU
        [ Global : int no_closingGU ]
        GU allowed only inside stacks 

$tetra_loop
        [ Global : int tetra_loop ]
        Fold with specially stable 4-loops 

$energy_set
        [ Global : int energy_set ]
        0 = BP; 1=any mit GC; 2=any mit AU-parameter 

$dangles
        [ Global : int dangles ]
        use dangling end energies (not in part_func!) 

$nonstandards
        [ Global : char * nonstandards ]
        contains allowed non standard bases 

$temperature
        [ Global : float temperature ]
        rescale parameters to this temperature 

$james_rule
        [ Global : int james_rule ]
        interior loops of size 2 get energy 0.8Kcal and no mismatches,
        default 1 

$logML
        [ Global : int logML ]
        use logarithmic multiloop energy function 

1.4.1.  class bond

[ created from struct bond ]

base pair 

bond_i_set(struct bond *,int );
bond_i_get(struct bond *);
        [ Member data: returns int  ]

bond_j_set(struct bond *,int );
bond_j_get(struct bond *);
        [ Member data: returns int  ]

----------

$base_pair
        [ Global : struct bond * base_pair ]
        list of base pairs 

$iindx
        [ Global : int * iindx ]

$pf_scale
        [ Global : float pf_scale ]

$fold_constrained
        [ Global : int fold_constrained ]

$do_backtrack
        [ Global : int do_backtrack ]

$backtrack_type
        [ Global : char backtrack_type ]
        usually 'F'; 'C' require (1,N) to be bonded; 'M' seq is part of
        a multi loop 

get_pr(i,j);
        [ returns float  ]
        Get probability of pair i.j from the pr array 

2.  Parsing and Comparing Structures
====================================

$STRUC = 1000
        [ Constant: int  ]

b2HIT(structure);
        [ returns char * ]
        Full -> HIT [incl. root] 

b2C(structure);
        [ returns char * ]
        Full -> Coarse [incl. root] 

b2Shapiro(structure);
        [ returns char * ]
        Full -> weighted Shapiro [i.r.] 

add_root(char *);
        [ returns char * ]
        {Tree} -> ({Tree}R) 

expand_Shapiro(coarse);
        [ returns char * ]
        add S for stacks to coarse struct 

expand_Full(structure);
        [ returns char * ]
        Full -> FFull 

unexpand_Full(ffull);
        [ returns char * ]
        FFull -> Full 

unweight(wcoarse);
        [ returns char * ]
        remove weights from coarse struct 

unexpand_aligned_F(align);
        [ returns void  ]

parse_structure(structure);
        [ returns void  ]
        make structure statistics 

$loop_size
        [ Global : int * loop_size ]
        loop sizes of a structure 

$helix_size
        [ Global : int * helix_size ]
        helix sizes of a structure 

$loop_degree
        [ Global : int * loop_degree ]
        loop degrees of a structure 

$loops
        [ Global : int loops ]
        n of loops and stacks 

$unpaired
        [ Global : int unpaired ]

$pairs
        [ Global : int pairs ]
        n of unpaired digits and pairs 

make_tree(struc);
        [ returns Tree * ]
        make input for tree_edit_distance 

tree_edit_distance(T1,T2);
        [ returns float  ]
        compare to structures using tree editing 

print_tree(t);
        [ returns void  ]
        mainly for debugging 

free_tree(t);
        [ returns void  ]
        free space allocated by make_tree 

Make_swString(string);
        [ returns swString * ]
        make input for string_edit_distance 

string_edit_distance(T1,T2);
        [ returns float  ]
        compare to structures using string alignment 

Make_bp_profile(length);
        [ returns float ** ]
        condense pair probability matrix pr into a vector containing probabilities
        for upstream paired, downstream paired and unpaired. This resulting
        probability profile is used as input for profile_edit_distance 

profile_edit_distance(T1,T2);
        [ returns float  ]
        align two probability profiles 

print_bppm(T);
        [ returns void  ]
        print string representation of probability profile 

free_profile(T);
        [ returns void  ]
        free space allocated in Make_bp_profile 

$edit_backtrack
        [ Global : int edit_backtrack ]
        set to 1 if you want backtracking 

$aligned_line
        [ Global : char ** aligned_line ]
        containes alignment after backtracking 

$cost_matrix
        [ Global : int cost_matrix ]
        0 usual costs (default), 1 Shapiro's costs 

3.  Utilities
=============

space(size);
        [ returns void * ]
        allocate space safely 

nrerror(message);
        [ returns void  ]
        die with error message 

init_rand();
        [ returns void  ]
        make random number seeds 

$xsubi
        [ Global : unsigned short * xsubi ]
        48bit random number 

urn();
        [ returns double  ]
        random number from [0..1] 

int_urn(from,to);
        [ returns int  ]
        random integer 

filecopy(from,to);
        [ returns void  ]

time_stamp();
        [ returns char * ]
        current date in a string 

random_string(l,symbols);
        [ returns char * ]

hamming(s1,s2);
        [ returns int  ]
        hamming distance 

get_line(fp);
        [ returns char * ]
        read one line 

PS_rna_plot(string,structure,file);
        [ returns int  ]
        write PostScript drawing of structure to file 

gmlRNA(string,structure,ssfile,option);
        [ returns int  ]
        structure drawing in gml 

PS_dot_plot(string,file);
        [ returns int  ]
        produce a PostScript dot plot of the pair probability matix 

read_parameter_file(fname);
        [ returns void  ]
        read energy parameters from file 

write_parameter_file(fname);
        [ returns void  ]
        write energy parameters to file %include array.i

4.  Pointer Handling Library
============================

%include pointer.i

The pointer.i library provides run-time support for managing and 
manipulating a variety of C/C++ pointer values.  In particular,
you can create various kinds of objects and dereference common
pointer types.  This is done through a common set of functions:

    ptrcast      - Casts a pointer to a new type
    ptrvalue     - Dereferences a pointer 
    ptrset       - Set the value of an object referenced by 
                   a pointer.
    ptrcreate    - Create a new object and return a pointer.
    ptrfree      - Free the memory allocated by ptrcreate.
    ptradd       - Increment/decrement a pointer value.
    ptrmap       - Make two datatypes equivalent to each other.
                   (Is a runtime equivalent of typedef).

When creating, dereferencing, or setting the value of pointer
variable, only the common C datatypes of int, short, long, float,
double, char, and char * are currently supported.   Other
datatypes may generate an error.

One of the more interesting aspects of this library is that
it operates with a wide range of datatypes.  For example,
the "ptrvalue" function can dereference "double *", "int *",
"long *", "char *", and other datatypes. Since SWIG encodes
pointers with type information, this can be done transparently
and in most cases, you can dereference a pointer without
ever knowing what type it actually is.

This library is primarily designed for utility, not high 
performance (the dynamic determination of pointer types takes
more work than most normal wrapper functions).  As a result,
you may achieve better performance by writing customized
"helper" functions if you're making lots of calls to these
functions in inner loops or other intensive operations.

ptrcast(ptr,type);
        Casts a pointer ptr to a new datatype given by the string type.
        type may be either the SWIG generated representation of a datatype
        or the C representation.  For example :
        
           ptrcast($ptr,"doublePtr");   # Perl5 representation
           ptrcast($ptr,"double *");    # C representation
        
        A new pointer value is returned.   ptr may also be an integer
        value in which case the value will be used to set the pointer
        value.  For example :
        
           $a = ptrcast(0,"VectorPtr");
        
        Will create a NULL pointer of type "VectorPtr"
        
        The casting operation is sensitive to formatting.  As a result,
        "double *" is different than "double*".  As a result of thumb,
        there should always be exactly one space between the C datatype
        and any pointer specifiers (*).
        
ptrvalue(ptr,index,type);
        Returns the value that a pointer is pointing to (ie. dereferencing).
        The type is automatically inferred by the pointer type--thus, an
        integer pointer will return an integer, a double will return a double,
        and so on.   The index and type fields are optional parameters.  When
        an index is specified, this function returns the value of ptr[index].
        This allows array access.   When a type is specified, it overrides
        the given pointer type.   Examples :
        
           ptrvalue($a)             #  Returns the value *a
           ptrvalue($a,10)          #  Returns the value a[10]
           ptrvalue($a,10,"double") #  Returns a[10] assuming a is a double *
        
ptrset(ptr,value,index,type);
        Sets the value pointed to by a pointer.  The type is automatically
        inferred from the pointer type so this function will work for
        integers, floats, doubles, etc...  The index and type fields are
        optional.  When an index is given, it provides array access.  When
        type is specified, it overrides the given pointer type.  Examples :
        
          ptrset($a,3)            # Sets the value *a = 3
          ptrset($a,3,10)         # Sets a[10] = 3
          ptrset($a,3,10,"int")   # Sets a[10] = 3 assuming a is a int *
        
ptrcreate(type,value,nitems);
        Creates a new object and returns a pointer to it.  This function 
        can be used to create various kinds of objects for use in C functions.
        type specifies the basic C datatype to create and value is an
        optional parameter that can be used to set the initial value of the
        object.  nitems is an optional parameter that can be used to create
        an array.  This function results in a memory allocation using
        malloc().  Examples :
        
          $a = ptrcreate("double")     # Create a new double, return pointer
          $a = ptrcreate("int",7)      # Create an integer, set value to 7
          $a = ptrcreate("int",0,1000) # Create an integer array with initial
                                       # values all set to zero
        
        This function only recognizes a few common C datatypes as listed below :
        
               int, short, long, float, double, char, char *, void
        
        All other datatypes will result in an error.  However, other
        datatypes can be created by using the ptrcast function.  For
        example:
        
         $a = ptrcast(ptrcreate("int",0,100),"unsigned int *")
        
ptrfree(ptr);
        Destroys the memory pointed to by ptr.  This function calls free()
        and should only be used with objects created by ptrcreate().  Since
        this function calls free, it may work with other objects, but this
        is generally discouraged unless you absolutely know what you're
        doing.
        
ptradd(ptr,offset);
        Adds a value to the current pointer value.  For the C datatypes of
        int, short, long, float, double, and char, the offset value is the
        number of objects and works in exactly the same manner as in C.  For
        example, the following code steps through the elements of an array
        
         $a = ptrcreate("double",0,100);    # Create an array double a[100]
         $b = $a;
         for ($i = 0; $i < 100; $i++) {
             ptrset($b,0.0025*$i);          # set *b = 0.0025*i
             $b = ptradd($b,1);             # b++ (go to next double)
         }
        
        In this case, adding one to b goes to the next double.
        
        For all other datatypes (including all complex datatypes), the
        offset corresponds to bytes.  This function does not perform any
        bounds checking and negative offsets are perfectly legal.  
        
ptrmap(type1,type2);
        This is a rarely used function that performs essentially the same
        operation as a C typedef.  To manage datatypes at run-time, SWIG
        modules manage an internal symbol table of type mappings.  This
        table keeps track of which types are equivalent to each other.  The
        ptrmap() function provides a mechanism for scripts to add symbols
        to this table.  For example :
        
           ptrmap("doublePtr","RealPtr");
        
        would make the types "doublePtr" and "RealPtr" equivalent to each
        other.  Pointers of either type could now be used interchangably.
        
        Normally this function is not needed, but it can be used to
        circumvent SWIG's normal type-checking behavior or to work around
        weird type-handling problems.
        
deref_any(ptr,index);

