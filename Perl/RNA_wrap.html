<HTML>
<HEAD>
<TITLE>
RNA_wrap.c</TITLE>
<BODY BGCOLOR="#ffffff">
<H1>RNA_wrap.c</H1>
[ Module  : RNA, Package : RNA ]<BR>

<HR><H1> Contents </H1>
<UL><LI> <A HREF="#s1_">1. Folding Routines</A>
<UL><LI> <A HREF="#s1_1_">1.1. Minimum free Energy Folding</A>
<LI> <A HREF="#s1_2_">1.2. Partition function Folding</A>
<LI> <A HREF="#s1_3_">1.3. Inverse Folding</A>
<LI> <A HREF="#s1_4_">1.4. Global Variables to Modify Folding</A>
<UL><LI> <A HREF="#s1_4_1_">1.4.1. class bond</A>
</UL></UL><LI> <A HREF="#s2_">2. Parsing and Comparing Structures</A>
<LI> <A HREF="#s3_">3. Utilities</A>
<LI> <A HREF="#s4_">4. Pointer Handling Library</A>
</UL>

<A name="s1_">
<HR><H2>1. Folding Routines</H2></A>
<A name="s1_1_">
<H3>1.1. Minimum free Energy Folding</H3></A>
<P><TT><B>fold(sequence,structure);</B></TT>
<BLOCKQUOTE>[ returns float  ]
<BR>   calculate mfe-structure of sequence   
</BLOCKQUOTE>

<P><TT><B>energy_of_struct(string,structure);</B></TT>
<BLOCKQUOTE>[ returns float  ]
<BR>   calculate energy of string on structure   
</BLOCKQUOTE>

<P><TT><B>free_arrays();</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   free arrays for mfe folding   
</BLOCKQUOTE>

<P><TT><B>initialize_fold(length);</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   allocate arrays for folding   
</BLOCKQUOTE>

<P><TT><B>update_fold_params();</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   recalculate parameters   
</BLOCKQUOTE>

<A name="s1_2_">
<H3>1.2. Partition function Folding</H3></A>
<P><TT><B>pf_fold(sequence,structure);</B></TT>
<BLOCKQUOTE>[ returns float  ]
<BR>   calculate partition function and base pair probabilities   
</BLOCKQUOTE>

<P><TT><B>init_pf_fold(length);</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   allocate space for pf_fold()   
</BLOCKQUOTE>

<P><TT><B>free_pf_arrays();</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   free arrays from pf_fold()   
</BLOCKQUOTE>

<P><TT><B>update_pf_params(length);</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>  recalculate energy parameters   
</BLOCKQUOTE>

<P><TT><B>bppm_symbol(x);</B></TT>
<BLOCKQUOTE>[ returns char  ]
<BR>   string representation of structure   
</BLOCKQUOTE>

<A name="s1_3_">
<H3>1.3. Inverse Folding</H3></A>
<P><TT><B>$symbolset</B></TT>
<BLOCKQUOTE>[ Global : char * symbolset ]
<BR>   alphabet default is &quot;AUGC&quot;   
</BLOCKQUOTE>

<P><TT><B>inverse_fold(start,target);</B></TT>
<BLOCKQUOTE>[ returns float  ]
<BR>   find sequences with predifined structure.
   the found sequence is written to start,
   return value is
      energy_of_struct(start, target) - fold(start, structure),
   i.e. 0. if search was successful;   
</BLOCKQUOTE>

<P><TT><B>inverse_pf_fold(start,target);</B></TT>
<BLOCKQUOTE>[ returns float  ]
<BR>    inverse folding maximising the frequency of target in the
    ensemble of structures, final sequence is written to start, returns 
       energy_of_struct(start, target) - part_func(start, structure)
  
</BLOCKQUOTE>

<P><TT><B>$final_cost</B></TT>
<BLOCKQUOTE>[ Global : float  final_cost ]
<BR>   when to stop inverse_pf_fold()   
</BLOCKQUOTE>

<P><TT><B>$give_up</B></TT>
<BLOCKQUOTE>[ Global : int  give_up ]
<BR>   default 0: try to minimize structure distance even if 
			 no exact solution can be found   
</BLOCKQUOTE>

<A name="s1_4_">
<H3>1.4. Global Variables to Modify Folding</H3></A>
<P><TT><B>$pr</B></TT>
<BLOCKQUOTE>[ Global : double * pr ]
<BR>    base pairing prob. matrix   
</BLOCKQUOTE>

<P><TT><B>$noGU</B></TT>
<BLOCKQUOTE>[ Global : int  noGU ]
<BR>   GU not allowed at all   
</BLOCKQUOTE>

<P><TT><B>$no_closingGU</B></TT>
<BLOCKQUOTE>[ Global : int  no_closingGU ]
<BR>   GU allowed only inside stacks   
</BLOCKQUOTE>

<P><TT><B>$tetra_loop</B></TT>
<BLOCKQUOTE>[ Global : int  tetra_loop ]
<BR>   Fold with specially stable 4-loops   
</BLOCKQUOTE>

<P><TT><B>$energy_set</B></TT>
<BLOCKQUOTE>[ Global : int  energy_set ]
<BR>   0 = BP; 1=any mit GC; 2=any mit AU-parameter   
</BLOCKQUOTE>

<P><TT><B>$dangles</B></TT>
<BLOCKQUOTE>[ Global : int  dangles ]
<BR>   use dangling end energies (not in part_func!)   
</BLOCKQUOTE>

<P><TT><B>$nonstandards</B></TT>
<BLOCKQUOTE>[ Global : char * nonstandards ]
<BR>   contains allowed non standard bases   
</BLOCKQUOTE>

<P><TT><B>$temperature</B></TT>
<BLOCKQUOTE>[ Global : float  temperature ]
<BR>   rescale parameters to this temperature   
</BLOCKQUOTE>

<P><TT><B>$james_rule</B></TT>
<BLOCKQUOTE>[ Global : int  james_rule ]
<BR>   interior loops of size 2 get energy 0.8Kcal and
			       no mismatches, default 1   
</BLOCKQUOTE>

<P><TT><B>$logML</B></TT>
<BLOCKQUOTE>[ Global : int  logML ]
<BR>   use logarithmic multiloop energy function   
</BLOCKQUOTE>

<A name="s1_4_1_">
<H4>1.4.1. class bond</H4></A>
[ created from struct bond ]<BR>
   base pair   

<P><TT><B>bond_i_set(struct bond *,int );
bond_i_get(struct bond *);</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR></BLOCKQUOTE>

<P><TT><B>bond_j_set(struct bond *,int );
bond_j_get(struct bond *);</B></TT>
<BLOCKQUOTE>[ Member data: returns int  ]
<BR></BLOCKQUOTE>

<P><TT><B>$base_pair</B></TT>
<BLOCKQUOTE>[ Global : struct bond * base_pair ]
<BR>   list of base pairs   
</BLOCKQUOTE>

<P><TT><B>$iindx</B></TT>
<BLOCKQUOTE>[ Global : int * iindx ]
<BR></BLOCKQUOTE>

<P><TT><B>$pf_scale</B></TT>
<BLOCKQUOTE>[ Global : float  pf_scale ]
<BR></BLOCKQUOTE>

<P><TT><B>$fold_constrained</B></TT>
<BLOCKQUOTE>[ Global : int  fold_constrained ]
<BR></BLOCKQUOTE>

<P><TT><B>$do_backtrack</B></TT>
<BLOCKQUOTE>[ Global : int  do_backtrack ]
<BR></BLOCKQUOTE>

<P><TT><B>$noLonelyPairs</B></TT>
<BLOCKQUOTE>[ Global : int  noLonelyPairs ]
<BR></BLOCKQUOTE>

<P><TT><B>$backtrack_type</B></TT>
<BLOCKQUOTE>[ Global : char  backtrack_type ]
<BR>   usually 'F'; 'C' require (1,N) to be bonded;
				   'M' seq is part of a multi loop   
</BLOCKQUOTE>

<P><TT><B>get_pr(i,j);</B></TT>
<BLOCKQUOTE>[ returns float  ]
<BR>   Get probability of pair i.j from the pr array   
</BLOCKQUOTE>

<A name="s2_">
<HR><H2>2. Parsing and Comparing Structures</H2></A>
<P><TT><B>$STRUC = 1000</B></TT>
<BLOCKQUOTE>[ Constant: int  ]
<BR></BLOCKQUOTE>

<P><TT><B>b2HIT(structure);</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   Full   -> HIT    [incl. root]        
</BLOCKQUOTE>

<P><TT><B>b2C(structure);</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   Full   -> Coarse [incl. root]        
</BLOCKQUOTE>

<P><TT><B>b2Shapiro(structure);</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   Full -> weighted Shapiro [i.r.]   
</BLOCKQUOTE>

<P><TT><B>add_root(char *);</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   {Tree} -> ({Tree}R)                  
</BLOCKQUOTE>

<P><TT><B>expand_Shapiro(coarse);</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   add S for stacks to coarse struct   
</BLOCKQUOTE>

<P><TT><B>expand_Full(structure);</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   Full   -> FFull                
</BLOCKQUOTE>

<P><TT><B>unexpand_Full(ffull);</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   FFull  -> Full                 
</BLOCKQUOTE>

<P><TT><B>unweight(wcoarse);</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   remove weights from coarse struct   
</BLOCKQUOTE>

<P><TT><B>unexpand_aligned_F(align);</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR></BLOCKQUOTE>

<P><TT><B>parse_structure(structure);</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   make structure statistics   
</BLOCKQUOTE>

<P><TT><B>$loop_size</B></TT>
<BLOCKQUOTE>[ Global : int * loop_size ]
<BR>   loop sizes of a structure   
</BLOCKQUOTE>

<P><TT><B>$helix_size</B></TT>
<BLOCKQUOTE>[ Global : int * helix_size ]
<BR>   helix sizes of a structure   
</BLOCKQUOTE>

<P><TT><B>$loop_degree</B></TT>
<BLOCKQUOTE>[ Global : int * loop_degree ]
<BR>   loop degrees of a structure   
</BLOCKQUOTE>

<P><TT><B>$loops</B></TT>
<BLOCKQUOTE>[ Global : int  loops ]
<BR>   n of loops and stacks   
</BLOCKQUOTE>

<P><TT><B>$unpaired</B></TT>
<BLOCKQUOTE>[ Global : int  unpaired ]
<BR></BLOCKQUOTE>

<P><TT><B>$pairs</B></TT>
<BLOCKQUOTE>[ Global : int  pairs ]
<BR>   n of unpaired digits and pairs   
</BLOCKQUOTE>

<P><TT><B>make_tree(struc);</B></TT>
<BLOCKQUOTE>[ returns Tree * ]
<BR>   make input for tree_edit_distance   
</BLOCKQUOTE>

<P><TT><B>tree_edit_distance(T1,T2);</B></TT>
<BLOCKQUOTE>[ returns float  ]
<BR>   compare to structures using tree editing   
</BLOCKQUOTE>

<P><TT><B>print_tree(t);</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   mainly for debugging   
</BLOCKQUOTE>

<P><TT><B>free_tree(t);</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   free space allocated by make_tree   
</BLOCKQUOTE>

<P><TT><B>Make_swString(string);</B></TT>
<BLOCKQUOTE>[ returns swString * ]
<BR>   make input for string_edit_distance   
</BLOCKQUOTE>

<P><TT><B>string_edit_distance(T1,T2);</B></TT>
<BLOCKQUOTE>[ returns float  ]
<BR>   compare to structures using string alignment   
</BLOCKQUOTE>

<P><TT><B>Make_bp_profile(length);</B></TT>
<BLOCKQUOTE>[ returns float ** ]
<BR>   condense pair probability matrix pr into a vector containing probabilities
   for upstream paired, downstream paired and unpaired. This resulting
   probability profile is used as input for profile_edit_distance   
</BLOCKQUOTE>

<P><TT><B>profile_edit_distance(T1,T2);</B></TT>
<BLOCKQUOTE>[ returns float  ]
<BR>   align two probability profiles   
</BLOCKQUOTE>

<P><TT><B>print_bppm(T);</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   print string representation of probability profile   
</BLOCKQUOTE>

<P><TT><B>free_profile(T);</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   free space allocated in Make_bp_profile   
</BLOCKQUOTE>

<P><TT><B>$edit_backtrack</B></TT>
<BLOCKQUOTE>[ Global : int  edit_backtrack ]
<BR>   set to 1 if you want backtracking   
</BLOCKQUOTE>

<P><TT><B>$aligned_line</B></TT>
<BLOCKQUOTE>[ Global : char ** aligned_line ]
<BR>   containes alignment after backtracking   
</BLOCKQUOTE>

<P><TT><B>$cost_matrix</B></TT>
<BLOCKQUOTE>[ Global : int  cost_matrix ]
<BR>   0 usual costs (default), 1 Shapiro's costs   
</BLOCKQUOTE>

<A name="s3_">
<HR><H2>3. Utilities</H2></A>
<P><TT><B>space(size);</B></TT>
<BLOCKQUOTE>[ returns void * ]
<BR>   allocate space safely   
</BLOCKQUOTE>

<P><TT><B>nrerror(message);</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   die with error message   
</BLOCKQUOTE>

<P><TT><B>init_rand();</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   make random number seeds   
</BLOCKQUOTE>

<P><TT><B>$xsubi</B></TT>
<BLOCKQUOTE>[ Global : unsigned short * xsubi ]
<BR>   current 48bit random number   
</BLOCKQUOTE>

<P><TT><B>urn();</B></TT>
<BLOCKQUOTE>[ returns double  ]
<BR>   random number from [0..1]   
</BLOCKQUOTE>

<P><TT><B>int_urn(from,to);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   random integer   
</BLOCKQUOTE>

<P><TT><B>filecopy(from,to);</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   inefficient `cp'   
</BLOCKQUOTE>

<P><TT><B>time_stamp();</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   current date in a string   
</BLOCKQUOTE>

<P><TT><B>random_string(l,symbols);</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   random string of length l using characters from symbols[]   
</BLOCKQUOTE>

<P><TT><B>hamming(s1,s2);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   calculate hamming distance   
</BLOCKQUOTE>

<P><TT><B>get_line(fp);</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   read one (arbitrary length) line from fp   
</BLOCKQUOTE>

<P><TT><B>pack_structure(struc);</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   pack secondary secondary structure, 5:1 compression using base 3 encoding   
</BLOCKQUOTE>

<P><TT><B>unpack_structure(packed);</B></TT>
<BLOCKQUOTE>[ returns char * ]
<BR>   unpack sec structure packed with pack_structure()   
</BLOCKQUOTE>

<P><TT><B>make_pair_table(structure);</B></TT>
<BLOCKQUOTE>[ returns short * ]
<BR>   returns a newly allocated table, such that:  table[i]=j if (i.j) pair or
   0 if i is unpaired, table[0] contains the length of the structure.   
</BLOCKQUOTE>

<P><TT><B>bp_distance(str1,str2);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   dist = {number of base pairs in one structure but not in the other} 
   same as edit distance with open-pair close-pair as move-set   
</BLOCKQUOTE>

<P><TT><B>PS_rna_plot(string,structure,file);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   write PostScript drawing of structure to file   
</BLOCKQUOTE>

<P><TT><B>gmlRNA(string,structure,ssfile,option);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   structure drawing in gml   
</BLOCKQUOTE>

<P><TT><B>ssv_rna_plot(string,structure,ssfile);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>  write coord file for SStructView   
</BLOCKQUOTE>

<P><TT><B>PS_dot_plot(string,file);</B></TT>
<BLOCKQUOTE>[ returns int  ]
<BR>   produce a PostScript dot plot of the pair probability matix   
</BLOCKQUOTE>

<P><TT><B>$rna_plot_type</B></TT>
<BLOCKQUOTE>[ Global : int  rna_plot_type ]
<BR>   0= simple coordinates, 1= naview   
</BLOCKQUOTE>

<P><TT><B>read_parameter_file(fname);</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   read energy parameters from file   
</BLOCKQUOTE>

<P><TT><B>write_parameter_file(fname);</B></TT>
<BLOCKQUOTE>[ returns void  ]
<BR>   write energy parameters to file   
  %include array.i
</BLOCKQUOTE>

<A name="s4_">
<HR><H2>4. Pointer Handling Library</H2></A>
<PRE></PRE>
<P><PRE>
%include pointer.i

The pointer.i library provides run-time support for managing and 
manipulating a variety of C/C++ pointer values.  In particular,
you can create various kinds of objects and dereference common
pointer types.  This is done through a common set of functions:

    ptrcast      - Casts a pointer to a new type
    ptrvalue     - Dereferences a pointer 
    ptrset       - Set the value of an object referenced by 
                   a pointer.
    ptrcreate    - Create a new object and return a pointer.
    ptrfree      - Free the memory allocated by ptrcreate.
    ptradd       - Increment/decrement a pointer value.
    ptrmap       - Make two datatypes equivalent to each other.
                   (Is a runtime equivalent of typedef).

When creating, dereferencing, or setting the value of pointer
variable, only the common C datatypes of int, short, long, float,
double, char, and char * are currently supported.   Other
datatypes may generate an error.

One of the more interesting aspects of this library is that
it operates with a wide range of datatypes.  For example,
the &quot;ptrvalue&quot; function can dereference &quot;double *&quot;, &quot;int *&quot;,
&quot;long *&quot;, &quot;char *&quot;, and other datatypes. Since SWIG encodes
pointers with type information, this can be done transparently
and in most cases, you can dereference a pointer without
ever knowing what type it actually is.

This library is primarily designed for utility, not high 
performance (the dynamic determination of pointer types takes
more work than most normal wrapper functions).  As a result,
you may achieve better performance by writing customized
&quot;helper&quot; functions if you're making lots of calls to these
functions in inner loops or other intensive operations.</PRE>

<P><TT><B>ptrcast(ptr,type);</B></TT>
<BLOCKQUOTE><PRE>Casts a pointer ptr to a new datatype given by the string type.
type may be either the SWIG generated representation of a datatype
or the C representation.  For example :

   ptrcast($ptr,&quot;doublePtr&quot;);   # Perl5 representation
   ptrcast($ptr,&quot;double *&quot;);    # C representation

A new pointer value is returned.   ptr may also be an integer
value in which case the value will be used to set the pointer
value.  For example :

   $a = ptrcast(0,&quot;VectorPtr&quot;);

Will create a NULL pointer of type &quot;VectorPtr&quot;

The casting operation is sensitive to formatting.  As a result,
&quot;double *&quot; is different than &quot;double*&quot;.  As a result of thumb,
there should always be exactly one space between the C datatype
and any pointer specifiers (*).
</PRE></BLOCKQUOTE>

<P><TT><B>ptrvalue(ptr,index,type);</B></TT>
<BLOCKQUOTE><PRE>Returns the value that a pointer is pointing to (ie. dereferencing).
The type is automatically inferred by the pointer type--thus, an
integer pointer will return an integer, a double will return a double,
and so on.   The index and type fields are optional parameters.  When
an index is specified, this function returns the value of ptr[index].
This allows array access.   When a type is specified, it overrides
the given pointer type.   Examples :

   ptrvalue($a)             #  Returns the value *a
   ptrvalue($a,10)          #  Returns the value a[10]
   ptrvalue($a,10,&quot;double&quot;) #  Returns a[10] assuming a is a double *
</PRE></BLOCKQUOTE>

<P><TT><B>ptrset(ptr,value,index,type);</B></TT>
<BLOCKQUOTE><PRE>Sets the value pointed to by a pointer.  The type is automatically
inferred from the pointer type so this function will work for
integers, floats, doubles, etc...  The index and type fields are
optional.  When an index is given, it provides array access.  When
type is specified, it overrides the given pointer type.  Examples :

  ptrset($a,3)            # Sets the value *a = 3
  ptrset($a,3,10)         # Sets a[10] = 3
  ptrset($a,3,10,&quot;int&quot;)   # Sets a[10] = 3 assuming a is a int *
</PRE></BLOCKQUOTE>

<P><TT><B>ptrcreate(type,value,nitems);</B></TT>
<BLOCKQUOTE><PRE>Creates a new object and returns a pointer to it.  This function 
can be used to create various kinds of objects for use in C functions.
type specifies the basic C datatype to create and value is an
optional parameter that can be used to set the initial value of the
object.  nitems is an optional parameter that can be used to create
an array.  This function results in a memory allocation using
malloc().  Examples :

  $a = ptrcreate(&quot;double&quot;)     # Create a new double, return pointer
  $a = ptrcreate(&quot;int&quot;,7)      # Create an integer, set value to 7
  $a = ptrcreate(&quot;int&quot;,0,1000) # Create an integer array with initial
                               # values all set to zero

This function only recognizes a few common C datatypes as listed below :

       int, short, long, float, double, char, char *, void

All other datatypes will result in an error.  However, other
datatypes can be created by using the ptrcast function.  For
example:

 $a = ptrcast(ptrcreate(&quot;int&quot;,0,100),&quot;unsigned int *&quot;)
</PRE></BLOCKQUOTE>

<P><TT><B>ptrfree(ptr);</B></TT>
<BLOCKQUOTE><PRE>Destroys the memory pointed to by ptr.  This function calls free()
and should only be used with objects created by ptrcreate().  Since
this function calls free, it may work with other objects, but this
is generally discouraged unless you absolutely know what you're
doing.
</PRE></BLOCKQUOTE>

<P><TT><B>ptradd(ptr,offset);</B></TT>
<BLOCKQUOTE><PRE>Adds a value to the current pointer value.  For the C datatypes of
int, short, long, float, double, and char, the offset value is the
number of objects and works in exactly the same manner as in C.  For
example, the following code steps through the elements of an array

 $a = ptrcreate(&quot;double&quot;,0,100);    # Create an array double a[100]
 $b = $a;
 for ($i = 0; $i &lt; 100; $i++) {
     ptrset($b,0.0025*$i);          # set *b = 0.0025*i
     $b = ptradd($b,1);             # b++ (go to next double)
 }

In this case, adding one to b goes to the next double.

For all other datatypes (including all complex datatypes), the
offset corresponds to bytes.  This function does not perform any
bounds checking and negative offsets are perfectly legal.  
</PRE></BLOCKQUOTE>

<P><TT><B>ptrmap(type1,type2);</B></TT>
<BLOCKQUOTE><PRE>This is a rarely used function that performs essentially the same
operation as a C typedef.  To manage datatypes at run-time, SWIG
modules manage an internal symbol table of type mappings.  This
table keeps track of which types are equivalent to each other.  The
ptrmap() function provides a mechanism for scripts to add symbols
to this table.  For example :

   ptrmap(&quot;doublePtr&quot;,&quot;RealPtr&quot;);

would make the types &quot;doublePtr&quot; and &quot;RealPtr&quot; equivalent to each
other.  Pointers of either type could now be used interchangably.

Normally this function is not needed, but it can be used to
circumvent SWIG's normal type-checking behavior or to work around
weird type-handling problems.
</PRE></BLOCKQUOTE>

<P><TT><B>deref_any(ptr,index);</B></TT>


</BODY>
</HTML>
