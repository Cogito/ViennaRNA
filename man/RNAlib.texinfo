\input texinfo   @c -*-texinfo-*-
@c Last changed Time-stamp: <1998-07-07 18:45:23 ivo>
@set revision $Id: RNAlib.texinfo,v 1.6 1998/07/07 16:46:21 ivo Exp $
@setfilename RNAlib.info
@settitle Vienna RNA Package
@ifclear Version
@set Version 1.3
@end ifclear
@iftex
@afourpaper
@end iftex
@ifinfo
@setchapternewpage odd
@end ifinfo
@titlepage
@sp 10
@title{Vienna RNA Package}
@sp
@subtitle{A Library for folding and comparing RNA secondary structures}

@vskip 0pt plus 1filll
Copyright @copyright{1994-1998} @author{Ivo Hofacker and Peter Stadler}
@c @smallexample
Revision @value{revision}
@c @end smallexample
@end titlepage

@node Top, Introduction, (dir), (dir)
@comment node-name, next,          previous, up

@ifinfo
This file documents the Vienna RNA Package Version @value{Version}

Copyright @copyright{1994-1998} Ivo Hofacker and Peter Stadler
@end ifinfo

@menu
* Introduction::                
* Folding Routines::		Functions for Folding RNA Secondary Structures
* Parsing and Comparing::	Functions to Manipulate Structures
* Utilities::			Odds and Ends
* Example::			A Small Example Program
* References::
* Function Index::
* Variable Index::
@end menu

@node Introduction, Folding Routines, Top, Top
@chapter Introduction

The core of the Vienna RNA Package is formed by a collection of routines
for the prediction and comparison of RNA secondary structures. These
routines can be accessed through stand-alone programs, such as RNAfold,
RNAdistance etc., which should be sufficient for most users. For those who
wish to develop their own programs we provide a library which can be linked
to your own code.

This document only describes the library and will be primarily useful to
programmers. The stand-alone programs are described in separate man
pages. The latest version of the package including source code and html
versions of the documentation can be found at
@ifclear texi2html
@url{http://www.tbi.univie.ac.at/~ivo/RNA/}.
@end ifclear
@ifset texi2html
@ifhtml
the <a href="http://www.tbi.univie.ac.at/~ivo/RNA/">ViennaRNA page</a>.
@end ifhtml
@end ifset
This manual documents version @value{Version}.

Please send comments and bug reports to
@ifclear texi2html
@email{ivo@@tbi.univie.ac.at}.
@end ifclear
@ifset texi2html
@ifhtml
<a href="mailto:ivo@tbi.univie.ac.at">&lt;Ivo.Hofacker@tbi.univie.ac.at&gt;</a>.
@end ifhtml
@end ifset

@node Folding Routines, Parsing and Comparing, Introduction, Top
@comment  node-name,  next,  previous,  up
@chapter  Folding Routines

@menu
* mfe Fold::     Calculating Minimum Free Energy Structures
* PF Fold::      Calculating Partition Functions and Pair Probabilities
* Inverse Fold:: Searching for Predefined Structures
* Fold Vars::    Global Variables for the Folding Routines
* Param Files::  Reading Energy Parameters from File
@end menu

@node mfe Fold, PF Fold, Folding Routines, Folding Routines

@section Minimum free Energy Folding
The library provides a fast dynamic programming minimum free energy
folding algorithm as described by @cite{Zuker & Stiegler (1981)}.
Associated functions are: 


@deftypefun float fold (char* @var{sequence}, char* @var{structure})
folds the @var{sequence} and returns the minimum free energy in kcal/mol;
the mfe structure in bracket notation (@pxref{notations}) is returned in
@var{structure}. Sufficient space for string of the same length as
@var{sequence} must be allocated for @var{structure} before calling
@code{fold()}. If @code{fold_constrained} (@pxref{Fold Vars,,Variables})
is 1, the @var{structure} string is interpreted on input as a list of
constraints for the folding. The characters `` | x < > `` mark bases that
are paired, unpaired, paired upstream, or downstream, respectively;
matching brackets `` ( ) `` denote base pairs, dots ``.'' are used for
unconstrained bases. Constrained folding works by assigning bonus energies
to all structures compliing with the constraint.
@end deftypefun

@deftypefun float energy_of_struct (char* @var{sequence}, char* @var{structure})
calculates the energy of @var{sequence} on the @var{structure}
@end deftypefun

@deftypefun void   initialize_fold (int @var{length})
allocates memory for folding sequences not longer than @var{length};
sets up pairing matrix and energy parameters. Has to be called before
the first call to @code{fold()}.
@end deftypefun

@deftypefun void   free_arrays ()
frees the memory allocated by @code{initialize_fold()}.
@end deftypefun

@deftypefun void   update_fold_params ()
call this to recalculate the pair matrix and energy parameters after a
change in folding parameters like @code{temperature} (@pxref{Fold Vars,,Variables}). 
@end deftypefun

Prototypes for these functions are declared in @file{fold.h}.

@node PF Fold, Inverse Fold, mfe Fold, Folding Routines
@section Partition Function Folding

Instead of the minimum free energy structure the partition function of
all possible structures and from that the pairing probability for every
possible pair can be calculated, using a dynamic programming algorithm
as described by @cite{McCaskill (1990)}. The  following
functions are provided:


@deftypefun float pf_fold (char* @var{sequence}, char* @var{structure})
calculates the partition function @math{Z} of @var{sequence} and returns
the free energy of the ensemble @math{F} in kcal/mol, where @math{F=-kT
ln(Z)}. If @var{structure} is not a NULL pointer on input, it contains on
return a string consisting of the letters `` . , | @{ @} ( ) `` denoting
bases that are essentially unpaired, weakly paired, strongly paired without
preference, weakly upstream (downstream) paired, or strongly up-
(down-)stream paired bases, respectively.  If @code{fold_constrained}
(@pxref{Fold Vars,,Variables}) is 1, the @var{structure} string is
interpreted on input as a list of constraints for the folding. The
character ``x`` marks bases that must be unpaired, matching brackets `` ( )
`` denote base pairs, all other characters are ignored. Any pairs
conflicting with the constraint will be forbidden. This usually sufficient
to ensure the constraints are honored.  If @code{do_backtrack} (@pxref{Fold
Vars,,Variables}) has been set to 0 base pairing probabilities will not
be computed (saving CPU time), otherwise the @code{pr[iindx[i]-j]}
(@pxref{Fold Vars,,Variables}) will contain the probability that bases i
and j pair.
@end deftypefun

@deftypefun void init_pf_fold (int @var{length})
allocates memory for folding sequences not longer than @var{length};
sets up pairing matrix and energy parameters. Has to be called before
the first call to @code{pf_fold()}.
@end deftypefun

@deftypefun void free_pf_arrays (void)
frees the memory allocated by @code{init_pf_fold()}.
@end deftypefun

@deftypefun void update_pf_params (int @var{length})
Call this function to recalculate the pair matrix and energy parameters 
after a change in folding parameters like temperature
(@pxref{Fold Vars,,Variables}). 
@end deftypefun

Prototypes for these functions are declared in @file{part_func.h}.

@node Inverse Fold, Fold Vars, PF Fold, Folding Routines
@section  Inverse Folding

We provide two functions that search for sequences with a given
structure, thereby inverting the folding routines.


@deftypefun float inverse_fold (char* @var{start}, char* @var{target})
searches for a sequence with minimum free energy structure 
@var{target}, starting with sequence @var{start}. It returns 0 if the
search was successful, otherwise a structure distance to @var{target}
is returned. The found sequence is returned in @var{start}. If @code{give_up}
@vindex give_up
is set to 1, the function will return as soon as it is
clear that the search will be unsuccessful, this speeds up the algorithm
if you are only interested in exact solutions. 
Since @code{inverse_fold()} calls @code{fold()} you have to allocate memory
for folding by calling @code{initialize_fold()}
@end deftypefun

@deftypefun float inverse_pf_fold (char* @var{start}, char* @var{target})
searches for a sequence with maximum probability to fold into structure
@var{target} using the partition function algorithm. It returns
-kT log(p) where p is the frequency of @var{target} in the ensemble of
possible structures. This is usually much slower than @code{inverse_fold()}.
Since @code{inverse_pf_fold()} calls @code{pf_fold()} you have to allocate
memory for folding by calling @code{init_pf_fold()}
@end deftypefun


@deftypevar char symbolset[]
The global variable @code{char symbolset[]} contains the allowed bases, and
is initially set to ``AUGC''. 
@end deftypevar

Prototypes for these functions are declared in @file{inverse.h}.

@node Fold Vars, Param Files , Inverse Fold, Folding Routines
@section   Global Variables for the Folding Routines

The following global variables change the behavior the folding
algorithms or contain additional information after folding.

@deftypevar int  noGU
do not allow GU pairs if equal 1; default is 0.
@end deftypevar

@deftypevar int  no_closingGU
if 1 allow GU pairs only inside stacks, not as closing pairs;
default is 0.
@end deftypevar

@deftypevar int  noLonelyPairs
Disallow all pairs which can @strong{only} occur as lonely pairs (i.e. as helix
of length 1). This avoids lonely base pairs in the predicted structures in
most cases.
@end deftypevar

@deftypevar int  tetra_loop
include special stabilizing energies for some tetra loops; default is 1.
@end deftypevar

@deftypevar int  energy_set
if 1 or 2: fold sequences from an artificial alphabet ABCD..., where A
pairs B, C pairs D, etc. using either GC (1) or AU parameters (2);
default is 0, you probably don't want to change it.
@end deftypevar

@deftypevar float temperature
rescale energy parameters to a temperature of @code{temperature} C.
Default is 37C. You have to call the update_@dots{}_params() functions after
changing this parameter. 
@end deftypevar

@deftypevar int dangles
if set to 0 no stabilizing energies are assigned to bases adjacent to
helices in free ends and multiloops (so called dangling ends). Normally
(@code{dangles = 1}) dangling end energies are assigned only to unpaired
bases and a base cannot participate simultaneously in two dangling ends. In
the partition function algorithm @code{pf_fold()} these checks are neglected.
If @code{dangles} is set to 2, the @code{fold()} and
@code{energy_of_struct()} function will also follow this convention. This
treatment of dangling ends gives more favorable energies to helices
directly adjacent to one another, which can be beneficial since such
helices often do engage in stabilizing interactions through co-axial
stacking.   Default is 1, @code{pf_fold()} treats 1 as 2. 
@end deftypevar

@deftypevar char* nonstandards
Lists additional base pairs that will be allowed to form in addition to 
GC, CG, AU, UA, GU and UG. Nonstandard base pairs are given a stacking
energy of 0.
@end deftypevar

@deftypevar {struct bond @{ int i,j;@}} base_pair
Contains a list of base pairs after a call to @code{fold()}.
@code{base_pair[0].i} contains the total number of pairs.
@end deftypevar

@deftypevar float* pr
contains the base pair probability matrix after a call to @code{pf_fold()}.
@end deftypevar

@deftypevar int* iindx
index array to move through pr. The probability for base i and j to form
a pair is in @code{pr[iindx[i]-j]}.
@end deftypevar

@deftypevar float  pf_scale
a scaling factor used by @code{pf_fold()} to avoid overflows. Should be set
to approximately exp@math{((-F/kT)/length)}, where @math{F} is an estimate
for the ensemble free energy, for example the minimum free energy. You must
call @code{update_pf_params()} or @code{init_pf_fold()} after changing this
parameter. If pf_scale is -1 (the default) , an estimate will be provided
automatically when calling @code{init_pf_fold()} or
@code{update_pf_params()}. The automatic estimate is usually insufficient
for sequences more than a few hundred bases long.
@end deftypevar

@deftypevar int    fold_constrained
If 1, calculate constrained minimum free energy structures. @xref{mfe Fold},
for more information. Default is 0;
@end deftypevar

@deftypevar int    do_backtrack
if 0, do not calculate pair probabilities in @code{pf_fold()}; this is about
twice as fast. Default is 1.
@end deftypevar

@deftypevar char backtrack_type
only for use by @code{inverse_fold()}; 'C': force (1,N) to be paired,
'M' fold as if the sequence were inside a multi-loop. Otherwise the
usual mfe structure is computed.
@end deftypevar

include @file{fold_vars.h} if you want to change any of these variables
from their defaults.

@node Param Files, , Fold Vars, Folding Routines
@section Energy Parameter Files

A default set of parameters, identical to the one described in @cite{Walter
et.al. (1994)}, is compiled into the library.
Alternately, parameters can be read from and written to a file.

@deftypefun void read_parameter_file (const char @var{fname}[])
reads energy parameters from file @var{fname}. See below for the format of
the parameter file.
@end deftypefun
@deftypefun void write_parameter_file (const char @var{fname}[])
writes current energy parameters to the file @var{fname}.
@end deftypefun

The following describes the file format expected by
@code{read_parameter_file()}. All energies should be given as integers in
units of 0.01kcal/mol.

@need 1000
The first line of the file should read
@*@t{## RNAfold parameter file}

@noindent lines of the form@*
@noindent @t{# token}@*
mark the beginning of a list of energy parameters of the type specified by
token. The following tokens are recognized:

@noindent @t{# stack_energies}@*
The list of free energies for stacked pairs. Since the library
distinguishes 8 types of pairs (no pair=0, CG=1, GC=2, GU=3, UG=4, AU=5,
UA=6, nonstandard=7), the list should be formated as an 8*8 matrix. As an
example the stacked pair 
@example
                      5'-GU-3'        5'-AC-3'
                      3'-CA-5'        3'-UG-5'  
@end example
@noindent corresponds to the entry [2,6], which should be identical to [5,1]. Be
careful to preserve the symmetry when editing parameter files.

@noindent @t{# stack_enthalpies}@*
enthalpies for stacked pairs, used to rescale stacking energies to
temperatures other than 37C. Same format as stack_energies.

@noindent @t{# hairpin}@*
Free energies of hairpin loops as a function of size. The list should
contain 31 entries on one or more lines. Since the minimum size of a
hairpin loop is 3 and we start counting with 0, the first three values
should be INF to indicate a forbidden value.

@noindent @t{# bulge}@*
Free energies of bulge loops. Should contain 31 entries, the first one
being INF. 

@noindent @t{# internal_loop}@*
Free energies of internal loops. Should contain 31 entries, the first 2
being INF. 

@noindent @t{# mismatch_interior}@*
Free energies for the interaction between the closing pair of an interior loop
and the two unpaired bases adjacent to the helix. This is a three
dimensional array indexed by the type of the closing pair (see above) and
the two unpaired bases. The library distinguishes 5 bases: A=1, C=2, G=3,
U=4 and 0 for anything else. The list therefore contains 8*5*5 entries and
should be formated either as an 8*25 matrix or 8 5*5 matrices. The order is
such that for example the mismatch 
@example
                               5'-CU-3'
                               3'-GC-5'
@end example

@noindent corresponds to entry [1,4,2] (CG=1, U=4, C=2).

@noindent @t{# mismatch_hairpin}@*
Same as above for hairpin loops.

@noindent @t{# mismatch_enthalpies}@*
Corresponding enthalpies for rescaling to temperatures other than 37C.

@noindent @t{# dangle5}@*
Energies for the interaction of an unpaired base on the 5' side and
adjacent to a helix in multiloops and free ends (the equivalent of mismatch
energies in interior and hairpin loops). The array is indexed by the type
of pair closing the helix and the unpaired base and, therefore, forms a 8*5
matrix. For example the dangling base in
@example
                               5'-C-3'
                               3'-GC-5'
@end example
@noindent corresponds to entry [1,2] (CG=1, C=2);

@noindent @t{# dangle3}@*
Same as above for bases on the 3' side of a helix.

@noindent @t{# ML_params}@*
For the energy of a multi-loop a function of the form
@code{E = cu*n_unpaired + ci*loop_degree + cc}
is used where n_unpaired is the number of unpaired bases in the loop and
loop_degree is the number of helices forming the loop. The line following
the token should contain the values cu cc ci (in that order).

@noindent @t{# Tetraloops}@*
Some tetraloops particularly stable tetraloops are assigned an energy
bonus. Up to forty tetraloops and their bonus energies can be listed
following the token, one sequence per line. For example:
@example
       GAAA    -200
@end example
@noindent assigns a bonus energy of -2 kcal/mol to tetraloops containing
the sequence GAAA. 

@noindent @t{# END}@*
Anything beyond this token will be ignored.

A parameter file need not be complete, it might may contain only a subset
of interaction parameters, such as only stacking energies. However, for
each type of interaction listed, all entries have to be present.
A @samp{*} may be used to indicate entries of a list that are to retain
their default value. For loop energies a @samp{x} may be used to indicate that
the value is to be extrapolated from the values for smaller loop sizes. 
Parameter files may contain C-style comments, i.e. any text between
@code{/*} and @code{*/} will be ignored. However, you may have no more
than one comment per line and no multi-line comments.

A parameter file listing the default parameter set should accompany your
distribution as @file{default.par}, the file @file{old.par} contains
parameters used in version 1.1b of the Package. 


@node Parsing and Comparing, Utilities, Folding Routines, Top
@chapter Parsing and Comparing of Structures

@menu
* notations::			Representations of Secondary Structures.
* Parsing::			Functions for Parsing and Coarse Graining.
* Distances::			Distances for RNA Secondary Structures
@end menu

@node notations, Parsing, Parsing and Comparing, Parsing and Comparing
@section Representations of Secondary Structures

The standard representation of a secondary structure is the ``bracket
notation'', where matching brackets symbolize base pairs and unpaired
bases are shown as dots. Alternatively, one may use two types of node
labels, 'P' for paired and 'U' for unpaired; a dot is then replaced by
'(U)', and each closed bracket is assigned an additional identifier 'P'.
We call this the expanded notation. In @cite{Fontana et al. (1993)} a
condensed
representation of the secondary structure is proposed, the so-called
homeomorphically irreducible tree (HIT) representation. Here a stack is
represented as a single pair of matching brackets labeled 'P' and
weighted by the number of base pairs.  Correspondingly, a contiguous
strain of unpaired bases is shown as one pair of matching brackets
labeled 'U' and weighted by its length.  Generally any string consisting
of matching brackets and identifiers is equivalent to a plane tree with
as many different types of nodes as there are identifiers.

@cite{Bruce Shapiro (1988)} proposed a coarse grained representation, which,
does not retain the full information of the secondary structure. He
represents the different structure elements by single matching brackets
and labels them as 'H' (hairpin loop), 'I' (interior loop), 'B'
(bulge), 'M' (multi-loop), and 'S' (stack). We extend his alphabet by an
extra letter for external elements 'E'. Again these identifiers may be
followed by a weight corresponding to the number of unpaired bases or
base pairs in the structure element.  All tree representations (except
for the dot-bracket form) can be encapsulated into a virtual root
(labeled 'R'), see the example below.

The following example illustrates the different linear tree representations
used by the package. All lines show the same secondary structure.

@example
a) .((((..(((...)))..((..)))).)).
   (U)(((((U)(U)((((U)(U)(U)P)P)P)(U)(U)(((U)(U)P)P)P)P)(U)P)P)(U)
b) (U)(((U2)((U3)P3)(U2)((U2)P2)P2)(U)P2)(U)
c) (((H)(H)M)B)
   ((((((H)S)((H)S)M)S)B)S)
   (((((((H)S)((H)S)M)S)B)S)E)
d) ((((((((H3)S3)((H2)S2)M4)S2)B1)S2)E2)R)
@end example

Above: Tree representations of secondary structures.  a) Full structure:
the first line shows the more convenient condensed notation which is
used by our programs; the second line shows the rather clumsy expanded
notation for completeness, b) HIT structure, c) different versions of
coarse grained structures: the second line is exactly Shapiro's
representation, the first line is obtained by neglecting the stems.
Since each loop is closed by a unique stem, these two lines are
equivalent.  The third line is an extension taking into account also the
external digits.  d) weighted coarse structure, this time including the
virtual root.

For the output of aligned structures from string editing, different
representations are needed, where we put the label on both sides.
The above examples for tree representations would then look like:

@example
a) (UU)(P(P(P(P(UU)(UU)(P(P(P(UU)(UU)(UU)P)P)P)(UU)(UU)(P(P(UU)(U...
b) (UU)(P2(P2(U2U2)(P2(U3U3)P3)(U2U2)(P2(U2U2)P2)P2)(UU)P2)(UU)
c) (B(M(HH)(HH)M)B)
   (S(B(S(M(S(HH)S)(S(HH)S)M)S)B)S)
   (E(S(B(S(M(S(HH)S)(S(HH)S)M)S)B)S)E)
d) (R(E2(S2(B1(S2(M4(S3(H3)S3)((H2)S2)M4)S2)B1)S2)E2)R)
@end example

Aligned structures additionally contain the gap character '_'.


@node Parsing, Distances, notations, Parsing and Comparing
@section Parsing and Coarse Graining of Structures

Several functions are provided for parsing structures and converting to
different representations.

@deftypefun char* expand_Full (char* @var{full})
converts the @var{full} structure from bracket notation to the
expanded notation including root.
@end deftypefun

@deftypefun char* b2HIT (char* @var{full})
converts the @var{full} structure from bracket notation to the HIT
notation including root.
@end deftypefun

@deftypefun char* b2C (char* @var{full})
converts the @var{full} structure from bracket notation to the a
coarse grained notation using the 'H' 'B' 'I' 'M' and 'R' identifiers. 
@end deftypefun

@deftypefun char* b2Shapiro (char* @var{full})
converts the @var{full} structure from bracket notation to the
@emph{weighted} coarse grained notation using the 'H' 'B' 'I' 'M' 'S' 'E' and
'R' identifiers.
@end deftypefun

@deftypefun char* expand_Shapiro (char* @var{coarse})
inserts missing 'S' identifiers in unweighted coarse grained structures
as obtained from @code{b2C()}.
@end deftypefun

@deftypefun char* add_root (char* @var{any})
adds a root to an un-rooted tree in any except bracket notation.
@end deftypefun

@deftypefun char* unexpand_Full (char* @var{expanded})
restores the bracket notation from an expanded full or HIT tree, that is
any tree using only identifiers 'U' 'P' and 'R'.
@end deftypefun

@deftypefun char* unweight (char* @var{expanded})
strip weights from any weighted tree.
@end deftypefun

All the above functions allocate memory for the strings they return.

@deftypefun void unexpand_aligned_F (char* @var{align[2]})
converts two aligned structures in expanded notation as produced by
@code{tree_edit_distance()} function back to bracket notation with '_'
as the gap character. The result overwrites the input.
@end deftypefun

@deftypefun void parse_structure (char* @var{full})
Collects a statistic of structure elements of the @var{full} structure in
bracket notation, writing to the following global variables:
@end deftypefun

@deftypevar int    loop_size[]
contains a list of all loop sizes. @code{loop_size[0]} contains the
number of external bases.
@end deftypevar

@deftypevar int    loop_degree[]
contains the corresponding list of loop degrees.
@end deftypevar

@deftypevar int    helix_size[]
contains a list of all stack sizes.
@end deftypevar

@deftypevar int    loops
contains the number of loops ( and therefore of stacks ).
@end deftypevar

@deftypevar int    pairs
contains the number of base pairs in the last parsed structure.
@end deftypevar

@deftypevar int unpaired
contains the number of unpaired bases.
@end deftypevar


Prototypes for the above functions can be found in @file{RNAstruct.h}.

@node Distances,  , Parsing, Parsing and Comparing
@section Distance Measures

@menu
* Tree Distances::		Using Tree Edit Distances to Compare Structures
* String Distances::		Using String Alignment for Comparison
* Profile Distances::		Comparing Pair probability Matrices
@end menu

A simple measure of dissimilarity between secondary structures of equal
length is the base pair distance, given by the number of pairs present in
only one of the two structures being compared. I.e. the number of base
pairs that have to be opened or closed to transform one structure into the
other. It is therefore particularly useful for comparing structures on the
same sequence. It is implemented by 

@deftypefun int bp_distance (char* @var{s1}, char* @var{s2})
returns the ``base pair'' distance between two secondary structures @var{s1}
and @var{s2}, which should have the same length.
@end deftypefun

For other cases a distance measure that allows for gaps is preferable.
We can define distances between structures as edit distances between
trees or their string representations. In the case of string distances
this is the same as ``sequence alignment''. Given a set of edit operations
and edit costs, the edit distance is given by the minimum sum of the
costs along an edit path converting one object into the other. Edit
distances like these always define a metric. The edit operations used by us
are insertion, deletion and replacement of nodes. 
String editing does not pay attention to the matching of brackets, while
in tree editing matching brackets represent a single node of the tree.
Tree editing is therefore usually preferable, although somewhat
slower. String edit distances are always smaller or equal to tree edit
distances.  

The different level of detail in the structure representations defined
above naturally leads to different measures of distance. For full
structures we use a cost of 1 for deletion or insertion of an unpaired
base and 2 for a base pair. Replacing an unpaired base for a pair incurs
a cost of 1.

Two cost matrices are provided for coarse grained structures:

@example
/*  Null,   H,   B,   I,   M,   S,   E     */
   @{   0,   2,   2,   2,   2,   1,   1@},   /* Null replaced */
   @{   2,   0,   2,   2,   2, INF, INF@},   /* H    replaced */
   @{   2,   2,   0,   1,   2, INF, INF@},   /* B    replaced */
   @{   2,   2,   1,   0,   2, INF, INF@},   /* I    replaced */
   @{   2,   2,   2,   2,   0, INF, INF@},   /* M    replaced */
   @{   1, INF, INF, INF, INF,   0, INF@},   /* S    replaced */
   @{   1, INF, INF, INF, INF, INF,   0@},   /* E    replaced */


/*  Null,   H,   B,   I,   M,   S,   E    */
   @{   0, 100,   5,   5,  75,   5,   5@},   /* Null replaced */
   @{ 100,   0,   8,   8,   8, INF, INF@},   /* H    replaced */
   @{   5,   8,   0,   3,   8, INF, INF@},   /* B    replaced */
   @{   5,   8,   3,   0,   8, INF, INF@},   /* I    replaced */
   @{  75,   8,   8,   8,   0, INF, INF@},   /* M    replaced */
   @{   5, INF, INF, INF, INF,   0, INF@},   /* S    replaced */
   @{   5, INF, INF, INF, INF, INF,   0@},   /* E    replaced */
@end example

The lower matrix uses the costs given in @cite{Shapiro (1990)}.
All distance functions use the following global variables:


@deftypevar int   cost_matrix
if 0, use the default cost matrix (upper matrix in example); otherwise
use Shapiro's costs (lower matrix).
@end deftypevar

@deftypevar int   edit_backtrack
produce an alignment of the two structures being compared by
tracing the editing path giving the minimum distance.
@end deftypevar

@deftypevar char* aligned_line[2]
contains the two aligned structures after a call to one of the distance
functions with
@code{edit_backtrack} set to 1. @xref{notations}, for
details on the representation of structures.
@end deftypevar

@node Tree Distances, String Distances, Distances, Distances
@subsection Functions for Tree Edit Distances


@deftypefun Tree* make_tree (char* @var{xstruc})
constructs a @code{Tree} ( essentially the postorder list ) of the
structure @var{xstruc}, for use in
@code{tree_edit_distance()}.
@var{xstruc} may be any rooted structure representation.
@end deftypefun

@deftypefun float tree_edit_distance (Tree* @var{T1}, Tree* @var{T2})
calculates the edit distance of the two trees @var{T1} and @var{T2}.
@end deftypefun

@deftypefun void free_tree (Tree* @var{t})
frees the memory allocated for @var{t}. 
@end deftypefun

Prototypes for the above functions can be found in @file{treedist.h}. The
type @code{Tree} is defined in @file{dist_vars.h}, which is automatically
included with @file{treedist.h}

@node String Distances, Profile Distances, Tree Distances, Distances
@subsection Functions for String Alignment

@deftypefun swString* Make_swString (char* @var{xstruc})
converts the structure @var{xstruc} into a format suitable for 
@code{string_edit_distance()}.
@end deftypefun

@deftypefun float string_edit_distance (swString* @var{T1}, swString* @var{T2})
calculates the string edit distance of @var{T1} and @var{T2}.
@end deftypefun

Prototypes for the above functions can be found in @file{stringdist.h}.

@node Profile Distances,  , String Distances, Distances
@subsection Functions for Comparison of Base Pair Probabilities

For comparison of base pair probability matrices, the matrices are first
condensed into probability profiles which are the compared by alignment.

@deftypefun float** Make_bp_profile (int @var{length})
reads the base pair probability matrix @code{pr} (@pxref{Fold
Vars,,Variables}) and calculates a profile, i.e. a vector containing for
each base the probabilities of being unpaired, upstream, or downstream
paired, respectively. The returned array is suitable for
@code{profile_edit_distance}.
@end deftypefun

@deftypefun float    profile_edit_distance (float** @var{T1}, float** @var{T2})
calculates an alignment distance of the two profiles @var{T1} and @var{T2}.
@end deftypefun

@deftypefun void     free_profile (float** @var{T})
frees the memory allocated for the profile @var{T}.
@end deftypefun

Prototypes for the above functions can be found in @file{profiledist.h}.


@node Utilities, Example, Parsing and Comparing, Top
@chapter Utilities

The following utilities are used and therefore provided by the library:

@deftypefun int PS_dot_plot (char* @var{sequence}, char* @var{filename})
reads base pair probabilities produced by @code{pf_fold()} from the
global array @code{pr} and the pair list @code{base_pair} produced by 
@code{fold()} and produces a postscript ``dot plot'' that is written to
@var{filename}. The ``dot plot'' represents each base pairing
probability by a square of corresponding area in a upper triangle
matrix. The lower part of the matrix contains the minimum free energy
structure. 
@end deftypefun

@deftypefun int PS_rna_plot (char* @var{sequence}, char* @var{structure}, char* @var{filename})
produces a secondary structure graph in PostScript and writes it to
@var{filename}. Note that this function has changed from previous versions
and now expects the structure to be plotted in dot-bracket notation as an
argument. It does not make use of the global @code{base_pair} array anymore.
@end deftypefun

@deftypefun int gmlRNA (char* @var{sequence}, char* @var{structure}, char* @var{filename}, char @var{option})
produces a secondary structure graph in the Graph Meta Language gml and
writes it to @var{filename}. If @code{option} is an uppercase letter the
@code{sequence} is used to label nodes, if @code{option} equals @kbd{'X'}
or @kbd{'x'} the resulting file will coordinates for an initial layout of
the graph.
@end deftypefun

@deftypevar int rna_plot_type
switches between different layout algorithms for drawing secondary
structures in @code{PS_rna_plot} and @code{gmlRNA}. Current possibility are
0 for a simple radial drawing or 1 for the modified radial drawing taken from
the @code{naview} program of @cite{Bruccoleri & Heinrich (1988)}.
@end deftypevar

@deftypefun char* random_string (int @var{l}, char* @var{symbols})
generates a ``random'' string of characters from @var{symbols} with
length @var{l}.
@end deftypefun

@deftypefun int    hamming (char* @var{s1}, char* @var{s2})
returns the number of positions in which @var{s1} and @var{s2} differ,
the so called ``Hamming'' distance. @var{s1} and @var{s2} should have the
same length.
@end deftypefun

@deftypefun {unsigned char*} pack_structure (char* @var{struc})
returns a binary string encoding the secondary structure @var{struc}
using a 5:1 compression scheme. The string is NULL terminated and can
therefore be used with standard string functions such as strcmp().
Useful for programs that need to keep many structures in memory.
@end deftypefun

@deftypefun char*  unpack_structure (unsigned char* @var{packed})
translate a compressed binary string produced by pack_structure() back into
the familiar dot bracket notation.
@end deftypefun

@deftypefun short* make_pair_table (char* @var{structure})
returns a newly allocated table, such that:  table[i]=j if (i.j) pair or 0
if i is unpaired, table[0] contains the length of the @var{structure}. 
@end deftypefun

@deftypefun char* time_stamp (void)
returns a string containing the current date in the format
``Fri Mar 19 21:10:57 1993''.
@end deftypefun

@deftypefun void   nrerror (char* @var{message})
writes @var{message} to stderr and aborts the program.
@end deftypefun

@deftypefun double urn ()
returns a pseudo random number in the range [0..1[, usually implemented
by calling @code{erand48()}.
@end deftypefun

@deftypevar {unsigned short} xsubi[3]
is used by @code{urn ()}. These should be set to some random number seeds
before the first call to @code{urn ()}.
@end deftypevar

@deftypefun int    int_urn (int @var{from}, int @var{to})
generates a pseudo random integer in the range [@var{from}, @var{to}].
@end deftypefun

@deftypefun void* space (unsigned int @var{size})
returns a pointer to @var{size} bytes of allocated and 0 initialized
memory; aborts with an error if memory is not available.
@end deftypefun

@deftypefun char* get_line (FILE* @var{fp})
reads a line of arbitrary length from the stream @var{*fp}, and returns
a pointer to the resulting string. The necessary memory is allocated and
should be released using @code{free()} when the string is no longer needed.
@end deftypefun

Prototypes for @code{PS_rna_plot()} and @code{PS_dot_plot()} reside in
@file{PS_dot.h}, the other functions are declared in @file{utils.h}.

@node Example, References, Utilities, Top
@chapter A Small Example Program

The following program exercises most commonly used functions of the library.
The program folds two sequences using both the mfe and partition function
algorithms and calculates the tree edit and profile distance of the
resulting structures and base pairing probabilities.


@example
#include  <stdio.h>
#include  <math.h>
#include  "utils.h"
#include  "fold_vars.h"
#include  "fold.h"
#include  "part_func.h"
#include  "inverse.h"
#include  "RNAstruct.h"
#include  "treedist.h"
#include  "stringdist.h"
#include  "profiledist.h"

void main()
@{
   char *seq1="CGCAGGGAUACCCGCG", *seq2="GCGCCCAUAGGGACGC",
        *struct1,* struct2,* xstruc;
   float e1, e2, tree_dist, string_dist, profile_dist, kT;
   Tree *T1, *T2;
   swString *S1, *S2;
   float **pf1, **pf2;

   /* fold at 30C instead of the default 37C */
   temperature = 30.;      /* must be set *before* initializing  */
   /* allocate memory for fold(), could be skipped */
   initialize_fold(strlen(seq1)); 

   /* allocate memory for structure and fold */
   struct1 = (char* ) space(sizeof(char)*(strlen(seq1)+1)); 
   e1 =  fold(seq1, struct1);

   struct2 = (char* ) space(sizeof(char)*(strlen(seq2)+1));
   e2 =  fold(seq2, struct2);

   free_arrays();     /* free arrays used in fold() */

   /* produce tree and string representations for comparison */
   xstruc = expand_Full(struct1);
   T1 = make_tree(xstruc);
   S1 = Make_swString(xstruc);
   free(xstruc);

   xstruc = expand_Full(struct2);
   T2 = make_tree(xstruc);
   S2 = Make_swString(xstruc);
   free(xstruc);

   /* calculate tree edit distance and aligned structures with gaps */
   edit_backtrack = 1;   
   tree_dist = tree_edit_distance(T1, T2);  
   free_tree(T1); free_tree(T2);
   unexpand_aligned_F(aligned_line);  
   printf("%s\n%s  %3.2f\n", aligned_line[0], aligned_line[1], tree_dist);

   /* same thing using string edit (alignment) distance */
   string_dist = string_edit_distance(S1, S2);
   free(S1); free(S2);
   printf("%s  mfe=%5.2f\n%s  mfe=%5.2f  dist=%3.2f\n",
        aligned_line[0], e1, aligned_line[1], e2, string_dist);

   /* for longer sequences one should also set a scaling factor for
      partition function folding, e.g: */
   kT = (temperature+273.15)*1.98717/1000.;  /* kT in kcal/mol */
   pf_scale = exp(-e1/kT/strlen(seq1));  
   init_pf_fold(strlen(seq1));  

   /* calculate partition function and base pair probabilities */
   e1 = pf_fold(seq1, struct1);
   pf1 = Make_bp_profile(strlen(seq1));

   e2 = pf_fold(seq2, struct2);
   pf2 = Make_bp_profile(strlen(seq2));
   
   free_pf_arrays();  /* free space allocated for pf_fold() */

   profile_dist = profile_edit_distance(pf1, pf2);
   printf("%s  free energy=%5.2f\n%s  free energy=%5.2f  dist=%3.2f\n",
        aligned_line[0], e1, aligned_line[1], e2, profile_dist);
   
   free_profile(pf1); free_profile(pf2);
@}
@end example

In a typical Unix environment you would compile this program using:
@kbd{cc -c example.c -I@var{hpath}}
and link using
@kbd{cc -o example -L@var{lpath} -lRNA -lm}
where @var{hpath} and @var{lpath} point to the location of the header
files and library, respectively.

@node References, Function Index, Example, Top
@chapter References

@itemize -
@item M. Zuker and P. Stiegler (1981)@*
   Optimal  computer  folding  of large RNA sequences using
   thermodynamic and auxiliary information, Nucl Acid Res 9: 133-148

@item J.S. McCaskill (1990)@*
   The equilibrium partition function and base pair binding
   probabilities for RNA secondary structures, Biopolymers 29: 1105-1119

@item D.H. Turner, N. Sugimoto and S.M. Freier (1988)@*
   RNA structure prediction, Ann Rev Biophys Biophys Chem 17: 167-192

@item J.A. Jaeger, D.H. Turner and M. Zuker (1989)@*
   Improved predictions of secondary structures for RNA, 
   Proc. Natl. Acad. Sci. 86: 7706-7710 

@item L. He, R. Kierzek, J. SantaLucia, A.E. Walter and D.H. Turner (1991)@*
   Nearest-Neighbor Parameters For GU Mismatches, 
   Biochemistry 30: 11124-11132

@item A.E. Peritz, R. Kierzek, N, Sugimoto, D.H. Turner (1991)@*
   Thermodynamic Study of Internal Loops in Oligoribonucleotides ... ,
   Biochemistry 30: 6428--6435

@item A. Walter, D. Turner, J. Kim, M. Lyttle, P. M@"uller, D. Mathews and M. Zuker (1994)@*
   Coaxial stacking of helices enhances binding of Oligoribonucleotides..,
   Proc. Natl. Acad. Sci. 91: 9218-9222

@item B.A. Shapiro, (1988)@*
   An algorithm for comparing multiple  RNA secondary structures,
   CABIOS 4, 381-393 

@item B.A. Shapiro and K. Zhang (1990)@*
   Comparing multiple RNA secondary structures using tree comparison,
   CABIOS 6, 309-318 

@item R. Bruccoleri and G. Heinrich (1988)@*
   An improved algorithm for nucleic acid secondary structure display,
   CABIOS 4, 167-173

@item W. Fontana , D.A.M. Konings, P.F. Stadler, P. Schuster (1993) @*
   Statistics of RNA secondary structures, Biopolymers 33, 1389-1404

@item W. Fontana, P.F. Stadler, E.G. Bornberg-Bauer, T. Griesmacher, I.L.
   Hofacker, M. Tacker, P. Tarazona, E.D. Weinberger, P. Schuster (1993)@*
   RNA folding and combinatory landscapes, Phys. Rev. E 47: 2083-2099

@item I.L. Hofacker, W. Fontana, P.F. Stadler, S. Bonhoeffer, M. Tacker, P.
   Schuster (1994) Fast Folding and Comparison of RNA Secondary Structures.
   Monatshefte f. Chemie 125: 167-188

@item I.L. Hofacker (1994) The Rules of the Evolutionary Game for RNA:
   A Statistical Characterization of the Sequence to Structure Mapping in RNA.
   PhD Thesis, University of Vienna.

@item D. Adams (1979) @*
   The hitchhiker's guide to the galaxy, Pan Books, London
@end itemize

@node Function Index, Variable Index, References, Top

@unnumbered Function Index
@printindex fn

@node Variable Index,  , Function Index, Top

@unnumbered Variable Index
@printindex vr
     
@contents
@bye

@c  LocalWords:  texinfo setfilename RNAlib settitle syncodeindex vr fn iftex
@c  LocalWords:  afourpaper ifinfo setchapternewpage titlepage sp vskip pt dir
@c  LocalWords:  filll mfe PF Params Zuker Stiegler pxref Freier al findex mol
@c  LocalWords:  compliing struct int params McCaskill pf pr iindx init func kT
@c  LocalWords:  vindex symbolset noGU GU closingGU tetra ABCD AU rescale UA CG
@c  LocalWords:  multiloops nonstandards UG GAAG GA AG exp xref vars Shapiro's
@c  LocalWords:  homeomorphically UU HH emph un unexpand unweight RNAstruct INF
@c  LocalWords:  xstruc treedist swString stringdist bp profiledist PS rna Fri
@c  LocalWords:  nrerror stderr congruential xsubi fp utils dist seq RNAfold CA
@c  LocalWords:  CGCAGGGAUACCCGCG GCGCCCAUAGGGACGC initialising strlen sizeof
@c  LocalWords:  printf Nucl Biopolymers Sugimoto Biophys Chem Proc Natl Sci CU
@c  LocalWords:  Kierzek SantaLucia CABIOS Zhang Konings Bornberg RNAdistance
@c  LocalWords:  Griesmacher Tarazona Weinberger Phys Monatshefte enthalpies cu
@c  LocalWords:  Chemie hitchhiker's printindex ci cc Tetraloops tetraloops url
@c  LocalWords:  GAAA html http www tbi univie ac ivo Param deftypefun var ln
@c  LocalWords:  deftypevar const fname samp erand kbd hpath lpath lRNA lm Acad
@c  LocalWords:  Peritz Oligoribonucleotides Lyttle uller Bonhoeffer ifclear lt
@c  LocalWords:  smallexample texi ifset ifhtml href ViennaRNA mailto gt noLP
@c  LocalWords:  initially co noindent gmlRNA gml naview Bruccoleri struc
@c  LocalWords:  strcmp LocalWords
