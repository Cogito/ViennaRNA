<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from RNAlib.texinfo on 18 December 1997 -->

<TITLE>Vienna RNA Package</TITLE>
</HEAD>
<BODY>
<H1>Vienna RNA Package</H1>
<P>
<P><HR><P>


<H2><A NAME="SEC1" HREF="RNAlib_toc.html#TOC1">Introduction</A></H2>

<P>
The core of the Vienna RNA Package is formed by a collection of routines
for the prediction and comparison of RNA secondary structures. These
routines can be accessed through stand-alone programs, such as RNAfold,
RNAdistance etc., which should be sufficient for most users. For those who
wish to develop their own programs we provide a library which can be linked
to your own code.

</P>
<P>
This document only describes the library and will be primarily useful to
programmers. The stand-alone programs are described in separate man
pages. The latest version of the package including source code and html
versions of the documentation can be found at
the <a href="http://www.tbi.univie.ac.at/~ivo/RNA/">ViennaRNA page</a>.
This manual documents version 1.2.

</P>
<P>
Please send comments and bug reports to
<a href="mailto:ivo@tbi.univie.ac.at">&lt;Ivo.Hofacker@tbi.univie.ac.at&gt;</a>.

</P>


<H2><A NAME="SEC2" HREF="RNAlib_toc.html#TOC2">Folding Routines</A></H2>



<H3><A NAME="SEC3" HREF="RNAlib_toc.html#TOC3">Minimum free Energy Folding</A></H3>
<P>
The library provides a fast dynamic programming minimum free energy
folding algorithm as described by M. Zuker, P. Stiegler (1981)
(see section <A HREF="RNAlib.html#SEC17">References</A>).
Associated functions are: 

</P>

<P>
<DL>
<DT><U>Function:</U> float <B>fold</B> <I>(char* <VAR>sequence</VAR>, char* <VAR>structure</VAR>)</I>
<DD><A NAME="IDX1"></A>
folds the <VAR>sequence</VAR> and returns the minimum free energy in kcal/mol;
the mfe structure in bracket notation (see section <A HREF="RNAlib.html#SEC9">Representations of Secondary Structures</A>) is returned in
<VAR>structure</VAR>. Sufficient space for string of the same length as
<VAR>sequence</VAR> must be allocated for <VAR>structure</VAR> before calling
<CODE>fold()</CODE>. If <CODE>fold_constrained</CODE> (see section <A HREF="RNAlib.html#SEC6">Global Variables for the Folding Routines</A>)
is 1, the <VAR>structure</VAR> string is interpreted on input as a list of
constraints for the folding. The characters " | x &#60; &#62; " mark bases that
are paired, unpaired, paired upstream, or downstream, respectively;
matching brackets " ( ) " denote base pairs, dots "." are used for
unconstrained bases. Constrained folding works by assigning bonus energies
to all structures compliing with the constraint.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>energy_of_struct</B> <I>(char* <VAR>sequence</VAR>, char* <VAR>structure</VAR>)</I>
<DD><A NAME="IDX2"></A>
calculates the energy of <VAR>sequence</VAR> on the <VAR>structure</VAR>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>initialize_fold</B> <I>(int <VAR>length</VAR>)</I>
<DD><A NAME="IDX3"></A>
allocates memory for folding sequences not longer than <VAR>length</VAR>;
sets up pairing matrix and energy parameters. Has to be called before
the first call to <CODE>fold()</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>free_arrays</B> <I>()</I>
<DD><A NAME="IDX4"></A>
frees the memory allocated by <CODE>initialize_fold()</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>update_fold_params</B> <I>()</I>
<DD><A NAME="IDX5"></A>
call this to recalculate the pair matrix and energy parameters after a
change in folding parameters like <CODE>temperature</CODE> (see section <A HREF="RNAlib.html#SEC6">Global Variables for the Folding Routines</A>). 
</DL>

</P>
<P>
Prototypes for these functions are declared in <TT>`fold.h'</TT>.

</P>


<H3><A NAME="SEC4" HREF="RNAlib_toc.html#TOC4">Partition Function Folding</A></H3>

<P>
Instead of the minimum free energy structure the partition function of
all possible structures and from that the pairing probability for every
possible pair can be calculated, using a dynamic programming algorithm
as described by J.S. McCaskill (1990) (see section <A HREF="RNAlib.html#SEC17">References</A>). The  following
functions are provided:

</P>

<P>
<DL>
<DT><U>Function:</U> float <B>pf_fold</B> <I>(char* <VAR>sequence</VAR>, char* <VAR>structure</VAR>)</I>
<DD><A NAME="IDX6"></A>
calculates the partition function Z of <VAR>sequence</VAR> and returns
the free energy of the ensemble F in kcal/mol, where F=-kT
ln(Z). If <VAR>structure</VAR> is not a NULL pointer on input, it contains on
return a string consisting of the letters " . , | { } ( ) " denoting
bases that are essentially unpaired, weakly paired, strongly paired without
preference, weakly upstream (downstream) paired, or strongly up-
(down-)stream paired bases, respectively.  If <CODE>fold_constrained</CODE>
(see section <A HREF="RNAlib.html#SEC6">Global Variables for the Folding Routines</A>) is 1, the <VAR>structure</VAR> string is
interpreted on input as a list of constraints for the folding. The
character "x" marks bases that must be unpaired, matching brackets " ( )
" denote base pairs, all other characters are ignored. Any pairs
conflicting with the constraint will be forbidden. This usually sufficient
to ensure the constraints are honored.  If <CODE>do_backtrack</CODE> (see section <A HREF="RNAlib.html#SEC6">Global Variables for the Folding Routines</A>) has been set to 0 base pairing probabilities will not
be computed (saving CPU time), otherwise the <CODE>pr[iindx[i]-j]</CODE>
(see section <A HREF="RNAlib.html#SEC6">Global Variables for the Folding Routines</A>) will contain the probability that bases i
and j pair.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>init_pf_fold</B> <I>(int <VAR>length</VAR>)</I>
<DD><A NAME="IDX7"></A>
allocates memory for folding sequences not longer than <VAR>length</VAR>;
sets up pairing matrix and energy parameters. Has to be called before
the first call to <CODE>pf_fold()</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>free_pf_arrays</B> <I>(void)</I>
<DD><A NAME="IDX8"></A>
frees the memory allocated by <CODE>init_pf_fold()</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>update_pf_params</B> <I>(int <VAR>length</VAR>)</I>
<DD><A NAME="IDX9"></A>
Call this function to recalculate the pair matrix and energy parameters 
after a change in folding parameters like temperature
(see section <A HREF="RNAlib.html#SEC6">Global Variables for the Folding Routines</A>). 
</DL>

</P>
<P>
Prototypes for these functions are declared in <TT>`part_func.h'</TT>.

</P>


<H3><A NAME="SEC5" HREF="RNAlib_toc.html#TOC5">Inverse Folding</A></H3>

<P>
We provide two functions that search for sequences with a given
structure, thereby inverting the folding routines.

</P>

<P>
<DL>
<DT><U>Function:</U> float <B>inverse_fold</B> <I>(char* <VAR>start</VAR>, char* <VAR>target</VAR>)</I>
<DD><A NAME="IDX10"></A>
searches for a sequence with minimum free energy structure 
<VAR>target</VAR>, starting with sequence <VAR>start</VAR>. It returns 0 if the
search was successful, otherwise a structure distance to <VAR>target</VAR>
is returned. The found sequence is returned in <VAR>start</VAR>. If <CODE>give_up</CODE>
<A NAME="IDX11"></A>
is set to 1, the function will return as soon as it is
clear that the search will be unsuccessful, this speeds up the algorithm
if you are only interested in exact solutions. 
Since <CODE>inverse_fold()</CODE> calls <CODE>fold()</CODE> you have to allocate memory
for folding by calling <CODE>initialize_fold()</CODE>
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>inverse_pf_fold</B> <I>(char* <VAR>start</VAR>, char* <VAR>target</VAR>)</I>
<DD><A NAME="IDX12"></A>
searches for a sequence with maximum probability to fold into structure
<VAR>target</VAR> using the partition function algorithm. It returns
-kT log(p) where p is the frequency of <VAR>target</VAR> in the ensemble of
possible structures. This is usually much slower than <CODE>inverse_fold()</CODE>.
Since <CODE>inverse_pf_fold()</CODE> calls <CODE>pf_fold()</CODE> you have to allocate
memory for folding by calling <CODE>init_pf_fold()</CODE>
</DL>

</P>

<P>
<DL>
<DT><U>Variable:</U> char <B>symbolset[]</B>
<DD><A NAME="IDX13"></A>
The global variable <CODE>char symbolset[]</CODE> contains the allowed bases. 
</DL>

</P>
<P>
Prototypes for these functions are declared in <TT>`inverse.h'</TT>.

</P>


<H3><A NAME="SEC6" HREF="RNAlib_toc.html#TOC6">Global Variables for the Folding Routines</A></H3>

<P>
The following global variables change the behavior the folding
algorithms or contain additional information after folding.

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>noGU</B>
<DD><A NAME="IDX14"></A>
do not allow GU pairs if equal 1; default is 0.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>no_closingGU</B>
<DD><A NAME="IDX15"></A>
if 1 allow GU pairs only inside stacks, not as closing pairs;
default is 0.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>tetra_loop</B>
<DD><A NAME="IDX16"></A>
include special stabilizing energies for some tetra loops; default is 1.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>energy_set</B>
<DD><A NAME="IDX17"></A>
if 1 or 2: fold sequences from an artificial alphabet ABCD..., where A
pairs B, C pairs D, etc. using either GC (1) or AU parameters (2);
default is 0, you probably don't want to change it.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> float <B>temperature</B>
<DD><A NAME="IDX18"></A>
rescale energy parameters to a temperature of <CODE>temperature</CODE> C.
Default is 37C. You have to call the update_..._params() functions after
changing this parameter. 
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>dangles</B>
<DD><A NAME="IDX19"></A>
if set to 0 no stabilizing energies are assigned to bases adjacent to
helices in free ends and multiloops (so called dangling ends). partition
function and mfe folding treat dangling ends differently: the mfe algorithm
assigns dangling end energies only to unpaired bases, while the partition
function algorithm does not check whether the base is paired or not.
If <CODE>dangles</CODE> is set to 2, the <CODE>energy_of_struct()</CODE> function will
follow the convention for pf folding.
Default is 1. 
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> char* <B>nonstandards</B>
<DD><A NAME="IDX20"></A>
The additional pairs are listed in <CODE>nonstandards</CODE>. For instance "GAAG"
would allow GA and AG pairs. Nonstandard base pairs are given a stacking
energy of 0.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> struct bond { int i,j;} <B>base_pair</B>
<DD><A NAME="IDX21"></A>
Contains a list of base pairs after a call to <CODE>fold()</CODE>.
<CODE>base_pair[0].i</CODE> contains the total number of pairs.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> float* <B>pr</B>
<DD><A NAME="IDX22"></A>
contains the base pair probability matrix after a call to <CODE>pf_fold()</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int* <B>iindx</B>
<DD><A NAME="IDX23"></A>
index array to move through pr. The probability for base i and j to form
a pair is in <CODE>pr[iindx[i]-j]</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> float <B>pf_scale</B>
<DD><A NAME="IDX24"></A>
a scaling factor used by <CODE>pf_fold()</CODE> to avoid overflows. Should be set
to approximately exp((-F/kT)/length), where F is an estimate
for the ensemble free energy, for example the minimum free energy. You must
call <CODE>update_pf_params()</CODE> or <CODE>init_pf_fold()</CODE> after changing this
parameter. If pf_scale is -1 (the default) , an estimate will be provided
automatically when calling <CODE>init_pf_fold()</CODE> or
<CODE>update_pf_params()</CODE>. The automatic estimate is usually insufficient
for sequences more than a few hundred bases long.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>fold_constrained</B>
<DD><A NAME="IDX25"></A>
If 1, calculate constrained minimum free energy structures. See section <A HREF="RNAlib.html#SEC3">Minimum free Energy Folding</A>,
for more information. Default is 0;
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>do_backtrack</B>
<DD><A NAME="IDX26"></A>
if 0, do not calculate pair probabilities in <CODE>pf_fold()</CODE>; this is about
twice as fast. Default is 1.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> char <B>backtrack_type</B>
<DD><A NAME="IDX27"></A>
only for use by <CODE>inverse_fold()</CODE>; 'C': force (1,N) to be paired,
'M' fold as if the sequence were inside a multi-loop. Otherwise the
usual mfe structure is computed.
</DL>

</P>
<P>
include <TT>`fold_vars.h'</TT> if you want to change any of these variables
from their defaults.

</P>


<H3><A NAME="SEC7" HREF="RNAlib_toc.html#TOC7">Energy Parameter Files</A></H3>

<P>
A default set of parameters, identical to the one described in A. Walter
et.al. (1994) see section <A HREF="RNAlib.html#SEC17">References</A>, is compiled into the library.
Alternately, parameters can be read from and written to a file.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>read_parameter_file</B> <I>(const char <VAR>fname</VAR>[])</I>
<DD><A NAME="IDX28"></A>
reads energy parameters from file <VAR>fname</VAR>. See below for the format of
the parameter file.
</DL>
<DL>
<DT><U>Function:</U> void <B>write_parameter_file</B> <I>(const char <VAR>fname</VAR>[])</I>
<DD><A NAME="IDX29"></A>
writes current energy parameters to the file <VAR>fname</VAR>.
</DL>

</P>
<P>
The following describes the file format expected by
<CODE>read_parameter_file()</CODE>. All energies should be given as integers in
units of 0.01kcal/mol.

</P>
<P>
The first line of the file should read
<BR><TT>## RNAfold parameter file</TT>

</P>
<P>
lines of the form<BR>
<TT># token</TT><BR>
mark the beginning of a list of energy parameters of the type specified by
token. The following tokens are recognized:

</P>
<P>
<TT># stack_energies</TT><BR>
The list of free energies for stacked pairs. Since the library
distinguishes 8 types of pairs (no pair=0, CG=1, GC=2, GU=3, UG=4, AU=5,
UA=6, nonstandard=7), the list should be formated as an 8*8 matrix. As an
example the stacked pair 

<PRE>
                      5'-GU-3'        5'-AC-3'
                      3'-CA-5'        3'-UG-5'  
</PRE>

<P>
corresponds to the entry [2,6], which should be identical to [5,1]. Be
careful to preserve the symmetry when editing parameter files.

</P>
<P>
<TT># stack_enthalpies</TT><BR>
enthalpies for stacked pairs, used to rescale stacking energies to
temperatures other than 37C. Same format as stack_energies.

</P>
<P>
<TT># hairpin</TT><BR>
Free energies of hairpin loops as a function of size. The list should
contain 31 entries on one or more lines. Since the minimum size of a
hairpin loop is 3 and we start counting with 0, the first three values
should be INF to indicate a forbidden value.

</P>
<P>
<TT># bulge</TT><BR>
Free energies of bulge loops. Should contain 31 entries, the first one
being INF. 

</P>
<P>
<TT># internal_loop</TT><BR>
Free energies of internal loops. Should contain 31 entries, the first 2
being INF. 

</P>
<P>
<TT># mismatch_interior</TT><BR>
Free energies for the interaction between the closing pair of an interior loop
and the two unpaired bases adjacent to the helix. This is a three
dimensional array indexed by the type of the closing pair (see above) and
the two unpaired bases. The library distinguishes 5 bases: A=1, C=2, G=3,
U=4 and 0 for anything else. The list therefore contains 8*5*5 entries and
should be formated either as an 8*25 matrix or 8 5*5 matrices. The order is
such that for example the mismatch 

<PRE>
                               5'-CU-3'
                               3'-GC-5'
</PRE>

<P>
corresponds to entry [1,4,2] (CG=1, U=4, C=2).

</P>
<P>
<TT># mismatch_hairpin</TT><BR>
Same as above for hairpin loops.

</P>
<P>
<TT># mismatch_enthalpies</TT><BR>
Corresponding enthalpies for rescaling to temperatures other than 37C.

</P>
<P>
<TT># dangle5</TT><BR>
Energies for the interaction of an unpaired base on the 5' side and
adjacent to a helix in multiloops and free ends (the equivalent of mismatch
energies in interior and hairpin loops). The array is indexed by the type
of pair closing the helix and the unpaired base and, therefore, forms a 8*5
matrix. For example the dangling base in

<PRE>
                               5'-C-3'
                               3'-GC-5'
</PRE>

<P>
corresponds to entry [1,2] (CG=1, C=2);

</P>
<P>
<TT># dangle3</TT><BR>
Same as above for bases on the 3' side of a helix.

</P>
<P>
<TT># ML_params</TT><BR>
For the energy of a multi-loop a function of the form
<CODE>E = cu*n_unpaired + ci*loop_degree + cc</CODE>
is used where n_unpaired is the number of unpaired bases in the loop and
loop_degree is the number of helices forming the loop. The line following
the token should contain the values cu cc ci (in that order).

</P>
<P>
<TT># Tetraloops</TT><BR>
Some tetraloops particularly stable tetraloops are assigned an energy
bonus. Up to forty tetraloops and their bonus energies can be listed
following the token, one sequence per line. For example:

<PRE>
       GAAA    -200
</PRE>

<P>
assigns a bonus energy of -2kcal/mol to tetraloops containing the sequence
GAAA. 

</P>
<P>
<TT># END</TT><BR>
Anything beyond this token will be ignored.

</P>
<P>
A parameter file need not be complete, it might may contain only a subset
of interaction parameters, such as only stacking energies. However, for
each type of interaction listed, all entries have to be present.
A <SAMP>`*'</SAMP> may be used to indicate entries of a list that are to retain
their default value. For loop energies a <SAMP>`x'</SAMP> may be used to indicate that
the value is to be extrapolated from the values for smaller loop sizes. 
Parameter files may contain C-style comments, i.e. any text between
<CODE>/*</CODE> and <CODE>*/</CODE> will be ignored. However, you may have no more
than one comment per line and no multi-line comments.

</P>
<P>
A parameter file listing the default parameter set should accompany your
distribution as <TT>`default.par'</TT>, the file <TT>`old.par'</TT> contains
parameters used in version 1.1b of the Package. 

</P>



<H2><A NAME="SEC8" HREF="RNAlib_toc.html#TOC8">Parsing and Comparing of Structures</A></H2>



<H3><A NAME="SEC9" HREF="RNAlib_toc.html#TOC9">Representations of Secondary Structures</A></H3>

<P>
The standard representation of a secondary structure is the "bracket
notation", where matching brackets symbolize base pairs and unpaired
bases are shown as dots. Alternatively, one may use two types of node
labels, 'P' for paired and 'U' for unpaired; a dot is then replaced by
'(U)', and each closed bracket is assigned an additional identifier 'P'.
We call this the expanded notation. In (Fontana et al. 1993) a condensed
representation of the secondary structure is proposed, the so-called
homeomorphically irreducible tree (HIT) representation. Here a stack is
represented as a single pair of matching brackets labeled 'P' and
weighted by the number of base pairs.  Correspondingly, a contiguous
strain of unpaired bases is shown as one pair of matching brackets
labeled 'U' and weighted by its length.  Generally any string consisting
of matching brackets and identifiers is equivalent to a plane tree with
as many different types of nodes as there are identifiers.

</P>
<P>
Bruce Shapiro (1988) proposed a coarse grained representation, which,
does not retain the full information of the secondary structure. He
represents the different structure elements by single matching brackets
and labels them as 'H' (hairpin loop), 'I' (interior loop), 'B'
(bulge), 'M' (multi-loop), and 'S' (stack). We extend his alphabet by an
extra letter for external elements 'E'. Again these identifiers may be
followed by a weight corresponding to the number of unpaired bases or
base pairs in the structure element.  All tree representations (except
for the dot-bracket form) can be encapsulated into a virtual root
(labeled 'R'), see the example below.

</P>
<P>
The following example illustrates the different linear tree representations
used by the package. All lines show the same secondary structure.

</P>

<PRE>
a) .((((..(((...)))..((..)))).)).
   (U)(((((U)(U)((((U)(U)(U)P)P)P)(U)(U)(((U)(U)P)P)P)P)(U)P)P)(U)
b) (U)(((U2)((U3)P3)(U2)((U2)P2)P2)(U)P2)(U)
c) (((H)(H)M)B)
   ((((((H)S)((H)S)M)S)B)S)
   (((((((H)S)((H)S)M)S)B)S)E)
d) ((((((((H3)S3)((H2)S2)M4)S2)B1)S2)E2)R)
</PRE>

<P>
Above: Tree representations of secondary structures.  a) Full structure:
the first line shows the more convenient condensed notation which is
used by our programs; the second line shows the rather clumsy expanded
notation for completeness, b) HIT structure, c) different versions of
coarse grained structures: the second line is exactly Shapiro's
representation, the first line is obtained by neglecting the stems.
Since each loop is closed by a unique stem, these two lines are
equivalent.  The third line is an extension taking into account also the
external digits.  d) weighted coarse structure, this time including the
virtual root.

</P>
<P>
For the output of aligned structures from string editing, different
representations are needed, where we put the label on both sides.
The above examples for tree representations would then look like:

</P>

<PRE>
a) (UU)(P(P(P(P(UU)(UU)(P(P(P(UU)(UU)(UU)P)P)P)(UU)(UU)(P(P(UU)(U...
b) (UU)(P2(P2(U2U2)(P2(U3U3)P3)(U2U2)(P2(U2U2)P2)P2)(UU)P2)(UU)
c) (B(M(HH)(HH)M)B)
   (S(B(S(M(S(HH)S)(S(HH)S)M)S)B)S)
   (E(S(B(S(M(S(HH)S)(S(HH)S)M)S)B)S)E)
d) (R(E2(S2(B1(S2(M4(S3(H3)S3)((H2)S2)M4)S2)B1)S2)E2)R)
</PRE>

<P>
Aligned structures additionally contain the gap character '_'.

</P>



<H3><A NAME="SEC10" HREF="RNAlib_toc.html#TOC10">Parsing and Coarse Graining of Structures</A></H3>

<P>
Several functions are provided for parsing structures and converting to
different representations.

</P>
<P>
<DL>
<DT><U>Function:</U> char* <B>expand_Full</B> <I>(char* <VAR>full</VAR>)</I>
<DD><A NAME="IDX30"></A>
converts the <VAR>full</VAR> structure from bracket notation to the
expanded notation including root.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char* <B>b2HIT</B> <I>(char* <VAR>full</VAR>)</I>
<DD><A NAME="IDX31"></A>
converts the <VAR>full</VAR> structure from bracket notation to the HIT
notation including root.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char* <B>b2C</B> <I>(char* <VAR>full</VAR>)</I>
<DD><A NAME="IDX32"></A>
converts the <VAR>full</VAR> structure from bracket notation to the a
coarse grained notation using the 'H' 'B' 'I' 'M' and 'R' identifiers. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char* <B>b2Shapiro</B> <I>(char* <VAR>full</VAR>)</I>
<DD><A NAME="IDX33"></A>
converts the <VAR>full</VAR> structure from bracket notation to the
<EM>weighted</EM> coarse grained notation using the 'H' 'B' 'I' 'M' 'S' 'E' and
'R' identifiers.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char* <B>expand_Shapiro</B> <I>(char* <VAR>coarse</VAR>)</I>
<DD><A NAME="IDX34"></A>
inserts missing 'S' identifiers in unweighted coarse grained structures
as obtained from <CODE>b2C()</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char* <B>add_root</B> <I>(char* <VAR>any</VAR>)</I>
<DD><A NAME="IDX35"></A>
adds a root to an un-rooted tree in any except bracket notation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char* <B>unexpand_Full</B> <I>(char* <VAR>expanded</VAR>)</I>
<DD><A NAME="IDX36"></A>
restores the bracket notation from an expanded full or HIT tree, that is
any tree using only identifiers 'U' 'P' and 'R'.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char* <B>unweight</B> <I>(char* <VAR>expanded</VAR>)</I>
<DD><A NAME="IDX37"></A>
strip weights from any weighted tree.
</DL>

</P>
<P>
All the above functions allocate memory for the strings they return.

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>unexpand_aligned_F</B> <I>(char* <VAR>align[2]</VAR>)</I>
<DD><A NAME="IDX38"></A>
converts two aligned structures in expanded notation as produced by
<CODE>tree_edit_distance()</CODE> function back to bracket notation with '_'
as the gap character. The result overwrites the input.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>parse_structure</B> <I>(char* <VAR>full</VAR>)</I>
<DD><A NAME="IDX39"></A>
Collects a statistic of structure elements of the <VAR>full</VAR> structure in
bracket notation, writing to the following global variables:
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>loop_size[]</B>
<DD><A NAME="IDX40"></A>
contains a list of all loop sizes. <CODE>loop_size[0]</CODE> contains the
number of external bases.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>loop_degree[]</B>
<DD><A NAME="IDX41"></A>
contains the corresponding list of loop degrees.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>helix_size[]</B>
<DD><A NAME="IDX42"></A>
contains a list of all stack sizes.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>loops</B>
<DD><A NAME="IDX43"></A>
contains the number of loops ( and therefore of stacks ).
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>pairs</B>
<DD><A NAME="IDX44"></A>
contains the number of base pairs in the last parsed structure.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>unpaired</B>
<DD><A NAME="IDX45"></A>
contains the number of unpaired bases.
</DL>

</P>

<P>
Prototypes for the above functions can be found in <TT>`RNAstruct.h'</TT>.

</P>


<H3><A NAME="SEC11" HREF="RNAlib_toc.html#TOC11">Distance Measures</A></H3>

<P>
We can now define distances between structures as edit distances between
trees or their string representations. In the case of string distances
this is the same as "sequence alignment". Given a set of edit operations
and edit costs, the edit distance is given by the minimum sum of the
costs along an edit path converting one object into the other. Edit
distances like these always define a metric. The edit operations used by us
are insertion, deletion and replacement of nodes. 
String editing does not pay attention to the matching of brackets, while
in tree editing matching brackets represent a single node of the tree.
Tree editing is therefore usually preferable, although somewhat
slower. String edit distances are always smaller or equal to tree edit
distances.  

</P>
<P>
The different level of detail in the structure representations defined
above naturally leads to different measures of distance. For full
structures we use a cost of 1 for deletion or insertion of an unpaired
base and 2 for a base pair. Replacing an unpaired base for a pair incurs
a cost of 1.

</P>
<P>
Two cost matrices are provided for coarse grained structures:

</P>

<PRE>
/*  Null,   H,   B,   I,   M,   S,   E     */
   {   0,   2,   2,   2,   2,   1,   1},   /* Null replaced */
   {   2,   0,   2,   2,   2, INF, INF},   /* H    replaced */
   {   2,   2,   0,   1,   2, INF, INF},   /* B    replaced */
   {   2,   2,   1,   0,   2, INF, INF},   /* I    replaced */
   {   2,   2,   2,   2,   0, INF, INF},   /* M    replaced */
   {   1, INF, INF, INF, INF,   0, INF},   /* S    replaced */
   {   1, INF, INF, INF, INF, INF,   0},   /* E    replaced */

/*  Null,   H,   B,   I,   M,   S,   E    */
   {   0, 100,   5,   5,  75,   5,   5},   /* Null replaced */
   { 100,   0,   8,   8,   8, INF, INF},   /* H    replaced */
   {   5,   8,   0,   3,   8, INF, INF},   /* B    replaced */
   {   5,   8,   3,   0,   8, INF, INF},   /* I    replaced */
   {  75,   8,   8,   8,   0, INF, INF},   /* M    replaced */
   {   5, INF, INF, INF, INF,   0, INF},   /* S    replaced */
   {   5, INF, INF, INF, INF, INF,   0},   /* E    replaced */
</PRE>

<P>
The lower matrix uses the costs given in Shapiro (1990).
All distance functions use the following global variables:

</P>

<P>
<DL>
<DT><U>Variable:</U> int <B>cost_matrix</B>
<DD><A NAME="IDX46"></A>
if 0, use the default cost matrix (upper matrix in example); otherwise
use Shapiro's costs (lower matrix).
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> int <B>edit_backtrack</B>
<DD><A NAME="IDX47"></A>
produce an alignment of the two structures being compared by
tracing the editing path giving the minimum distance.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> char* <B>aligned_line[2]</B>
<DD><A NAME="IDX48"></A>
contains the two aligned structures after a call to one of the distance
functions with
<CODE>edit_backtrack</CODE> set to 1. See section <A HREF="RNAlib.html#SEC9">Representations of Secondary Structures</A>, for
details on the representation of structures.
</DL>

</P>


<H4><A NAME="SEC12" HREF="RNAlib_toc.html#TOC12">Functions for Tree Edit Distances</A></H4>

<P>
<DL>
<DT><U>Function:</U> Tree* <B>make_tree</B> <I>(char* <VAR>xstruc</VAR>)</I>
<DD><A NAME="IDX49"></A>
constructs a <CODE>Tree</CODE> ( essentially the postorder list ) of the
structure <VAR>xstruc</VAR>, for use in
<CODE>tree_edit_distance()</CODE>.
<VAR>xstruc</VAR> may be any rooted structure representation.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>tree_edit_distance</B> <I>(Tree* <VAR>T1</VAR>, Tree* <VAR>T2</VAR>)</I>
<DD><A NAME="IDX50"></A>
calculates the edit distance of the two trees <VAR>T1</VAR> and <VAR>T2</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>free_tree</B> <I>(Tree* <VAR>t</VAR>)</I>
<DD><A NAME="IDX51"></A>
frees the memory allocated for <VAR>t</VAR>. 
</DL>

</P>
<P>
Prototypes for the above functions can be found in <TT>`treedist.h'</TT>. The
type <CODE>Tree</CODE> is defined in <TT>`dist_vars.h'</TT>, which is automatically
included with <TT>`treedist.h'</TT>

</P>


<H4><A NAME="SEC13" HREF="RNAlib_toc.html#TOC13">Functions for String Alignment</A></H4>

<P>
<DL>
<DT><U>Function:</U> swString* <B>Make_swString</B> <I>(char* <VAR>xstruc</VAR>)</I>
<DD><A NAME="IDX52"></A>
converts the structure <VAR>xstruc</VAR> into a format suitable for 
<CODE>string_edit_distance()</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>string_edit_distance</B> <I>(swString* <VAR>T1</VAR>, swString* <VAR>T2</VAR>)</I>
<DD><A NAME="IDX53"></A>
calculates the string edit distance of <VAR>T1</VAR> and <VAR>T2</VAR>.
</DL>

</P>
<P>
Prototypes for the above functions can be found in <TT>`stringdist.h'</TT>.

</P>


<H4><A NAME="SEC14" HREF="RNAlib_toc.html#TOC14">Functions for Comparison of Base Pair Probabilities</A></H4>

<P>
For comparison of base pair probability matrices, the matrices are first
condensed into probability profiles which are the compared by alignment.

</P>
<P>
<DL>
<DT><U>Function:</U> float** <B>Make_bp_profile</B> <I>(int <VAR>length</VAR>)</I>
<DD><A NAME="IDX54"></A>
reads the base pair probability matrix <CODE>pr</CODE> (see section <A HREF="RNAlib.html#SEC6">Global Variables for the Folding Routines</A>) and calculates a profile, i.e. a vector containing for
each base the probabilities of being unpaired, upstream, or downstream
paired, respectively. The returned array is suitable for
<CODE>profile_edit_distance</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> float <B>profile_edit_distance</B> <I>(float** <VAR>T1</VAR>, float** <VAR>T2</VAR>)</I>
<DD><A NAME="IDX55"></A>
calculates an alignment distance of the two profiles <VAR>T1</VAR> and <VAR>T2</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>free_profile</B> <I>(float** <VAR>T</VAR>)</I>
<DD><A NAME="IDX56"></A>
frees the memory allocated for the profile <VAR>T</VAR>.
</DL>

</P>
<P>
Prototypes for the above functions can be found in <TT>`profiledist.h'</TT>.

</P>



<H2><A NAME="SEC15" HREF="RNAlib_toc.html#TOC15">Utilities</A></H2>

<P>
The following utilities are used and therefore provided by the library:

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>PS_dot_plot</B> <I>(char* <VAR>sequence</VAR>, char* <VAR>filename</VAR>)</I>
<DD><A NAME="IDX57"></A>
reads base pair probabilities produced by <CODE>pf_fold()</CODE> from the
global array <CODE>pr</CODE> and the pair list <CODE>base_pair</CODE> produced by 
<CODE>fold()</CODE> and produces a postscript "dot plot" that is written to
<VAR>filename</VAR>. The "dot plot" represents each base pairing
probability by a square of corresponding area in a upper triangle
matrix. The lower part of the matrix contains the minimum free energy
structure. 
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>PS_rna_plot</B> <I>(char* <VAR>sequence</VAR>, char* <VAR>structure</VAR>, char* <VAR>filename</VAR>)</I>
<DD><A NAME="IDX58"></A>
produces a secondary structure graph in PostScript and writes it to
<VAR>filename</VAR>. Note that this function has changed from previous versions
and now expects the structure to be plotted in dot-bracket notation as an
argument. It does not make use of the global <CODE>base_pair</CODE> array anymore.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>gmlRNA</B> <I>(char* <VAR>sequence</VAR>, char* <VAR>structure</VAR>, char* <VAR>filename</VAR>, char <VAR>option</VAR>)</I>
<DD><A NAME="IDX59"></A>
produces a secondary structure graph in the Graph Meta Language gml and
writes it to <VAR>filename</VAR>. If <CODE>option</CODE> is an uppercase letter the
<CODE>sequence</CODE> is used to label nodes, if <CODE>option</CODE> equals <KBD>'X'</KBD>
or <KBD>'x'</KBD> the resulting file will coordinates for an initial layout of
the graph.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char* <B>random_string</B> <I>(int <VAR>l</VAR>, char* <VAR>symbols</VAR>)</I>
<DD><A NAME="IDX60"></A>
generates a "random" string of characters from <VAR>symbols</VAR> with
length <VAR>l</VAR>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>hamming</B> <I>(char* <VAR>s1</VAR>, char* <VAR>s2</VAR>)</I>
<DD><A NAME="IDX61"></A>
returns the number of positions in which <VAR>s1</VAR> and <VAR>s2</VAR> differ,
the so called "Hamming" distance.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char* <B>time_stamp</B> <I>(void)</I>
<DD><A NAME="IDX62"></A>
returns a string containing the current date in the format
"Fri Mar 19 21:10:57 1993".
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void <B>nrerror</B> <I>(char* <VAR>message</VAR>)</I>
<DD><A NAME="IDX63"></A>
writes <VAR>message</VAR> to stderr and aborts the program.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> double <B>urn</B> <I>()</I>
<DD><A NAME="IDX64"></A>
returns a pseudo random number in the range [0..1[, usually implemented
by calling <CODE>erand48()</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Variable:</U> unsigned short <B>xsubi[3]</B>
<DD><A NAME="IDX65"></A>
is used by <CODE>urn ()</CODE>. These should be set to some random number seeds
before the first call to <CODE>urn ()</CODE>.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> int <B>int_urn</B> <I>(int <VAR>from</VAR>, int <VAR>to</VAR>)</I>
<DD><A NAME="IDX66"></A>
generates a pseudo random integer in the range [<VAR>from</VAR>, <VAR>to</VAR>].
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> void* <B>space</B> <I>(unsigned int <VAR>size</VAR>)</I>
<DD><A NAME="IDX67"></A>
returns a pointer to <VAR>size</VAR> bytes of allocated and 0 initialized
memory; aborts with an error if memory is not available.
</DL>

</P>
<P>
<DL>
<DT><U>Function:</U> char* <B>get_line</B> <I>(FILE* <VAR>fp</VAR>)</I>
<DD><A NAME="IDX68"></A>
reads a line of arbitrary length from the stream <VAR>*fp</VAR>, and returns
a pointer to the resulting string. The necessary memory is allocated and
should be released using <CODE>free()</CODE> when the string is no longer needed.
</DL>

</P>
<P>
Prototypes for <CODE>PS_rna_plot()</CODE> and <CODE>PS_dot_plot()</CODE> reside in
<TT>`PS_dot.h'</TT>, the other functions are declared in <TT>`utils.h'</TT>.

</P>


<H2><A NAME="SEC16" HREF="RNAlib_toc.html#TOC16">A Small Example Program</A></H2>

<P>
The following program exercises most commonly used functions of the library.
The program folds two sequences using both the mfe and partition function
algorithms and calculates the tree edit and profile distance of the
resulting structures and base pairing probabilities.

</P>


<PRE>
#include  &#60;stdio.h&#62;
#include  &#60;math.h&#62;
#include  "utils.h"
#include  "fold_vars.h"
#include  "fold.h"
#include  "part_func.h"
#include  "inverse.h"
#include  "RNAstruct.h"
#include  "treedist.h"
#include  "stringdist.h"
#include  "profiledist.h"

void main()
{
   char *seq1="CGCAGGGAUACCCGCG", *seq2="GCGCCCAUAGGGACGC",
        *struct1,* struct2,* xstruc;
   float e1, e2, tree_dist, string_dist, profile_dist, kT;
   Tree *T1, *T2;
   swString *S1, *S2;
   float **pf1, **pf2;

   /* fold at 30C instead of the default 37C */
   temperature = 30.;      /* must be set *before* initializing  */
   /* allocate memory for fold(), could be skipped */
   initialize_fold(strlen(seq1)); 

   /* allocate memory for structure and fold */
   struct1 = (char* ) space(sizeof(char)*(strlen(seq1)+1)); 
   e1 =  fold(seq1, struct1);

   struct2 = (char* ) space(sizeof(char)*(strlen(seq2)+1));
   e2 =  fold(seq2, struct2);

   free_arrays();     /* free arrays used in fold() */

   /* produce tree and string representations for comparison */
   xstruc = expand_Full(struct1);
   T1 = make_tree(xstruc);
   S1 = Make_swString(xstruc);
   free(xstruc);

   xstruc = expand_Full(struct2);
   T2 = make_tree(xstruc);
   S2 = Make_swString(xstruc);
   free(xstruc);

   /* calculate tree edit distance and aligned structures with gaps */
   edit_backtrack = 1;   
   tree_dist = tree_edit_distance(T1, T2);  
   free_tree(T1); free_tree(T2);
   unexpand_aligned_F(aligned_line);  
   printf("%s\n%s  %3.2f\n", aligned_line[0], aligned_line[1], tree_dist);

   /* same thing using string edit (alignment) distance */
   string_dist = string_edit_distance(S1, S2);
   free(S1); free(S2);
   printf("%s  mfe=%5.2f\n%s  mfe=%5.2f  dist=%3.2f\n",
        aligned_line[0], e1, aligned_line[1], e2, string_dist);

   /* for longer sequences one should also set a scaling factor for
      partition function folding, e.g: */
   kT = (temperature+273.15)*1.98717/1000.;  /* kT in kcal/mol */
   pf_scale = exp(-e1/kT/strlen(seq1));  
   init_pf_fold(strlen(seq1));  

   /* calculate partition function and base pair probabilities */
   e1 = pf_fold(seq1, struct1);
   pf1 = Make_bp_profile(strlen(seq1));

   e2 = pf_fold(seq2, struct2);
   pf2 = Make_bp_profile(strlen(seq2));
   
   free_pf_arrays();  /* free space allocated for pf_fold() */

   profile_dist = profile_edit_distance(pf1, pf2);
   printf("%s  free energy=%5.2f\n%s  free energy=%5.2f  dist=%3.2f\n",
        aligned_line[0], e1, aligned_line[1], e2, profile_dist);
   
   free_profile(pf1); free_profile(pf2);
}
</PRE>

<P>
In a typical Unix environment you would compile this program using:
<KBD>cc -c example.c -I<VAR>hpath</VAR></KBD>
and link using
<KBD>cc -o example -L<VAR>lpath</VAR> -lRNA -lm</KBD>
where <VAR>hpath</VAR> and <VAR>lpath</VAR> point to the location of the header
files and library, respectively.

</P>


<H2><A NAME="SEC17" HREF="RNAlib_toc.html#TOC17">References</A></H2>


<UL>
<LI>M. Zuker, P. Stiegler (1981)<BR>

   Optimal  computer  folding  of large RNA sequences using
   thermodynamic and auxiliary information, Nucl Acid Res 9: 133-148

<LI>J.S. McCaskill (1990)<BR>

   The equilibrium partition function and base pair binding
   probabilities for RNA secondary structures, Biopolymers 29: 1105-1119

<LI>D.H. Turner, N. Sugimoto and S.M. Freier (1988)<BR>

   RNA structure prediction, Ann Rev Biophys Biophys Chem 17: 167-192

<LI>J.A. Jaeger, D.H. Turner and M. Zuker (1989)<BR>

   Improved predictions of secondary structures for RNA, 
   Proc. Natl. Acad. Sci. 86: 7706-7710 

<LI>L. He, R. Kierzek, J. SantaLucia, A.E. Walter and D.H. Turner (1991)<BR>

   Nearest-Neighbor Parameters For GU Mismatches, 
   Biochemistry 30: 11124-11132

<LI>A.E. Peritz, R. Kierzek, N, Sugimoto, D.H. Turner (1991)<BR>

   Thermodynamic Study of Internal Loops in Oligoribonucleotides ... ,
   Biochemistry 30: 6428--6435

<LI>A. Walter, D Turner, J Kim, M Lyttle, P M&uuml;ller, D Mathews, M Zuker (1994)<BR>

   Coaxial stacking of helices enhances binding of Oligoribonucleotides..,
   Proc. Natl. Acad. Sci. 91: 9218-9222

<LI>B.A. Shapiro, (1988)<BR>

   An algorithm for comparing multiple  RNA secondary structures,
   CABIOS 4, 381-393 

<LI>B.A. Shapiro, K. Zhang  (1990)<BR>

   Comparing multiple RNA secondary structures using tree comparison,
   CABIOS 6, 309-318 

<LI>W. Fontana , D.A.M. Konings, P.F. Stadler, P. Schuster (1993) <BR>

   Statistics of RNA secondary structures, Biopolymers 33, 1389-1404

<LI>W. Fontana, P.F. Stadler, E.G. Bornberg-Bauer, T. Griesmacher, I.L.

   Hofacker, M. Tacker, P. Tarazona, E.D. Weinberger, P. Schuster (1993)<BR>
   RNA folding and combinatory landscapes, Phys. Rev. E 47: 2083-2099

<LI>I.L. Hofacker, W. Fontana, P.F. Stadler, S. Bonhoeffer, M. Tacker, P.

   Schuster (1994) Fast Folding and Comparison of RNA Secondary Structures.
   Monatshefte f. Chemie 125: 167-188

<LI>I.L. Hofacker (1994) The Rules of the Evolutionary Game for RNA:

   A Statistical Characterization of the Sequence to Structure Mapping in RNA.
   PhD Thesis, University of Vienna.

<LI>D. Adams (1979) <BR>

   The hitchhiker's guide to the galaxy, Pan Books, London
</UL>



<H2><A NAME="SEC18" HREF="RNAlib_toc.html#TOC18">Function Index</A></H2>
<P>
<H2>a</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX35">add_root</A>
</DIR>
<H2>b</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX32">b2C</A>
<LI><A HREF="RNAlib.html#IDX31">b2HIT</A>
<LI><A HREF="RNAlib.html#IDX33">b2Shapiro</A>
</DIR>
<H2>e</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX2">energy_of_struct</A>
<LI><A HREF="RNAlib.html#IDX30">expand_Full</A>
<LI><A HREF="RNAlib.html#IDX34">expand_Shapiro</A>
</DIR>
<H2>f</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX1">fold</A>
<LI><A HREF="RNAlib.html#IDX4">free_arrays</A>
<LI><A HREF="RNAlib.html#IDX8">free_pf_arrays</A>
<LI><A HREF="RNAlib.html#IDX56">free_profile</A>
<LI><A HREF="RNAlib.html#IDX51">free_tree</A>
</DIR>
<H2>g</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX68">get_line</A>
<LI><A HREF="RNAlib.html#IDX59">gmlRNA</A>
</DIR>
<H2>h</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX61">hamming</A>
</DIR>
<H2>i</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX7">init_pf_fold</A>
<LI><A HREF="RNAlib.html#IDX3">initialize_fold</A>
<LI><A HREF="RNAlib.html#IDX66">int_urn</A>
<LI><A HREF="RNAlib.html#IDX10">inverse_fold</A>
<LI><A HREF="RNAlib.html#IDX12">inverse_pf_fold</A>
</DIR>
<H2>m</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX54">Make_bp_profile</A>
<LI><A HREF="RNAlib.html#IDX52">Make_swString</A>
<LI><A HREF="RNAlib.html#IDX49">make_tree</A>
</DIR>
<H2>n</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX63">nrerror</A>
</DIR>
<H2>p</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX39">parse_structure</A>
<LI><A HREF="RNAlib.html#IDX6">pf_fold</A>
<LI><A HREF="RNAlib.html#IDX55">profile_edit_distance</A>
<LI><A HREF="RNAlib.html#IDX57">PS_dot_plot</A>
<LI><A HREF="RNAlib.html#IDX58">PS_rna_plot</A>
</DIR>
<H2>r</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX60">random_string</A>
<LI><A HREF="RNAlib.html#IDX28">read_parameter_file</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX67">space</A>
<LI><A HREF="RNAlib.html#IDX53">string_edit_distance</A>
</DIR>
<H2>t</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX62">time_stamp</A>
<LI><A HREF="RNAlib.html#IDX50">tree_edit_distance</A>
</DIR>
<H2>u</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX38">unexpand_aligned_F</A>
<LI><A HREF="RNAlib.html#IDX36">unexpand_Full</A>
<LI><A HREF="RNAlib.html#IDX37">unweight</A>
<LI><A HREF="RNAlib.html#IDX5">update_fold_params</A>
<LI><A HREF="RNAlib.html#IDX9">update_pf_params</A>
<LI><A HREF="RNAlib.html#IDX64">urn</A>
</DIR>
<H2>w</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX29">write_parameter_file</A>
</DIR>

</P>



<H2><A NAME="SEC19" HREF="RNAlib_toc.html#TOC19">Variable Index</A></H2>
<P>
<H2>a</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX48">aligned_line[2]</A>
</DIR>
<H2>b</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX27">backtrack_type</A>
<LI><A HREF="RNAlib.html#IDX21">base_pair</A>
</DIR>
<H2>c</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX46">cost_matrix</A>
</DIR>
<H2>d</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX19">dangles</A>
<LI><A HREF="RNAlib.html#IDX26">do_backtrack</A>
</DIR>
<H2>e</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX47">edit_backtrack</A>
<LI><A HREF="RNAlib.html#IDX17">energy_set</A>
</DIR>
<H2>f</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX25">fold_constrained</A>
</DIR>
<H2>g</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX11">give_up</A>
</DIR>
<H2>h</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX42">helix_size[]</A>
</DIR>
<H2>i</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX23">iindx</A>
</DIR>
<H2>l</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX41">loop_degree[]</A>
<LI><A HREF="RNAlib.html#IDX40">loop_size[]</A>
<LI><A HREF="RNAlib.html#IDX43">loops</A>
</DIR>
<H2>n</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX15">no_closingGU</A>
<LI><A HREF="RNAlib.html#IDX14">noGU</A>
<LI><A HREF="RNAlib.html#IDX20">nonstandards</A>
</DIR>
<H2>p</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX44">pairs</A>
<LI><A HREF="RNAlib.html#IDX24">pf_scale</A>
<LI><A HREF="RNAlib.html#IDX22">pr</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX13">symbolset[]</A>
</DIR>
<H2>t</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX18">temperature</A>
<LI><A HREF="RNAlib.html#IDX16">tetra_loop</A>
</DIR>
<H2>u</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX45">unpaired</A>
</DIR>
<H2>x</H2>
<DIR>
<LI><A HREF="RNAlib.html#IDX65">xsubi[3]</A>
</DIR>
     
<P><HR><P>
This document was generated on 18 December 1997 using the
<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
translator version 1.51.</P>
</BODY>
</HTML>
