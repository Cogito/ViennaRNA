/*
 * FILE : RNA_wrap.c
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Build 883)
 * 
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */


#define SWIGCODE
/* $Header: /cvsroot/SWIG1.1/swig_lib/perl5/headers.swg,v 1.1.1.1 1999/02/28 02:00:54 beazley Exp $ */
/* Implementation : PERL 5 */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
/* Needed on some windows machines---since MS plays funny
   games with the header files under C++ */
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Get rid of free and malloc defined by perl */
#undef free
#undef malloc

#include <string.h>
#ifdef __cplusplus
}
#endif
/* Definitions for compiling Perl extensions on a variety of machines */

#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a) __declspec(dllexport) a
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a) a _export 
#	else
#	    define SWIGEXPORT(a) a 
#	endif
#   endif
#else
#   define SWIGEXPORT(a) a 
#endif

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerlObj *pPerl = (CPerlObj *) this;
#define MAGIC_CAST   (int (CPerlObj::*)(SV *, MAGIC *))
#define SWIGCLASS_STATIC 
#else
#define MAGIC_PPERL
#define MAGIC_CAST
#define SWIGCLASS_STATIC static
#endif

#if defined(WIN32) && defined(PERL_OBJECT) && !defined(PerlIO_exportFILE)
#define PerlIO_exportFILE(fh,fl) (FILE*)(fh)
#endif

/* Modifications for newer Perl 5.005 releases */

#if !defined(PERL_REVISION) || ((PERL_REVISION >= 5) && ((PERL_VERSION < 5) || ((PERL_VERSION == 5) && (PERL_SUBVERSION < 50))))
#ifndef PL_sv_yes
#define PL_sv_yes sv_yes
#endif
#ifndef PL_sv_undef
#define PL_sv_undef sv_undef
#endif
#ifndef PL_na
#define PL_na na
#endif
#endif

/******************************************************************************
 * Pointer type-checking code
 *****************************************************************************/

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SWIG_NOINCLUDE
extern void SWIG_MakePtr(char *, void *, char *);
#ifndef PERL_OBJECT
extern void SWIG_RegisterMapping(char *, char *, void *(*)(void *));
#else
#define SWIG_RegisterMapping(a,b,c) _SWIG_RegisterMapping(pPerl,a,b,c);
extern void _SWIG_RegisterMapping(CPerlObj *,char *, char *, void *(*)(void *),int);
#endif
#ifndef PERL_OBJECT
extern char *SWIG_GetPtr(SV *, void **, char *);
#else
extern char *_SWIG_GetPtr(CPerlObj *, SV *, void **, char *);
#define SWIG_GetPtr(a,b,c) _SWIG_GetPtr(pPerl,a,b,c)
#endif

#else

#ifdef SWIG_GLOBAL
#define SWIGSTATICRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGSTATICRUNTIME(a) static a
#endif

/* These are internal variables.   Should be static */

typedef struct SwigPtrType {
  char               *name;
  int                 len;
  void               *(*cast)(void *);
  struct SwigPtrType *next;
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */
static int SwigStart[256];             /* Table containing starting positions    */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

#ifndef PERL_OBJECT
SWIGSTATICRUNTIME(void) 
SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {
#else
#define SWIG_RegisterMapping(a,b,c) _SWIG_RegisterMapping(pPerl, a,b,c)
SWIGSTATICRUNTIME(void)
_SWIG_RegisterMapping(CPerlObj *pPerl, char *origtype, char *newtype, void *(*cast)(void *)) {
#endif

  int i;
  SwigPtrType *t = 0, *t1;

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc(SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }
  while (t->next) {
    if (strcmp(t->name,newtype) == 0) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;
  t->next = t1;
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATICRUNTIME(void) 
SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGSTATICRUNTIME(char *) 
SWIG_GetPtr(SV *sv, void **ptr, char *_t)
#else
#define SWIG_GetPtr(a,b,c) _SWIG_GetPtr(pPerl,a,b,c)
SWIGSTATICRUNTIME(char *)
_SWIG_GetPtr(CPerlObj *pPerl, SV *sv, void **ptr, char *_t)
#endif
{
  char temp_type[256];
  char *name,*_c;
  int  len,i,start,end;
  IV   tmp;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;

  /* If magical, apply more magic */

  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return "Not a valid pointer value";
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return (char *) 0;
    }
  } else if (! SvOK(sv)) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return (char *) 0;
  } else if (SvTYPE(sv) == SVt_RV) {       /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return (char *) 0;
    else
      return "Not a valid pointer value";
  } else {                                 /* Don't know what it is */
      *(ptr) = (void *) 0;
      return "Not a valid pointer value";
  }
  if (_t) {
    /* Now see if the types match */      

    if (!sv_isa(sv,_t)) {
      _c = HvNAME(SvSTASH(SvRV(sv)));
      if (!SwigPtrSort) {
	qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort);  
	for (i = 0; i < 256; i++) {
	  SwigStart[i] = SwigPtrN;
	}
	for (i = SwigPtrN-1; i >= 0; i--) {
	  SwigStart[SwigPtrTable[i].name[0]] = i;
	}
	for (i = 255; i >= 1; i--) {
	  if (SwigStart[i-1] > SwigStart[i])
	    SwigStart[i-1] = SwigStart[i];
	}
	SwigPtrSort = 1;
	for (i = 0; i < SWIG_CACHESIZE; i++)  
	  SwigCache[i].stat = 0;
      }
      /* First check cache for matches.  Uses last cache value as starting point */
      cache = &SwigCache[SwigLastCache];
      for (i = 0; i < SWIG_CACHESIZE; i++) {
	if (cache->stat) {
	  if (strcmp(_t,cache->name) == 0) {
	    if (strcmp(_c,cache->mapped) == 0) {
	      cache->stat++;
	      *ptr = (void *) tmp;
	      if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
	      return (char *) 0;
	    }
	  }
	}
	SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	if (!SwigLastCache) cache = SwigCache;
	else cache++;
      }

      start = SwigStart[_t[0]];
      end = SwigStart[_t[0]+1];
      sp = &SwigPtrTable[start];
      while (start < end) {
	if (swigcmp(_t,sp) == 0) break;
	sp++;
	start++;
      }
      if (start > end) sp = 0;
      while (start <= end) {
	if (swigcmp(_t,sp) == 0) {
	  name = sp->name;
	  len = sp->len;
	  tp = sp->next;
	  while(tp) {
	    if (tp->len >= 255) {
	      return _c;
	    }
	    strcpy(temp_type,tp->name);
	    strncat(temp_type,_t+len,255-tp->len);
	    if (sv_isa(sv,temp_type)) {
	      /* Get pointer value */
	      *ptr = (void *) tmp;
	      if (tp->cast) *ptr = (*(tp->cast))(*ptr);

	      strcpy(SwigCache[SwigCacheIndex].mapped,_c);
	      strcpy(SwigCache[SwigCacheIndex].name,_t);
	      SwigCache[SwigCacheIndex].stat = 1;
	      SwigCache[SwigCacheIndex].tp = tp;
	      SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
	      return (char *) 0;
	    }
	    tp = tp->next;
	  } 
	}
	sp++;
	start++;
      }
      /* Didn't find any sort of match for this data.  
	 Get the pointer value and return the received type */
      *ptr = (void *) tmp;
      return _c;
    } else {
      /* Found a match on the first try.  Return pointer value */
      *ptr = (void *) tmp;
      return (char *) 0;
    }
  } 
  *ptr = (void *) tmp;
  return (char *) 0;
}

#endif
#ifdef __cplusplus
}
#endif






/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerlObj *pPerl, SV *sv, char *name, int (CPerlObj::*set)(SV *, MAGIC *), int (CPerlObj::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = get;
  mg->mg_virtual->svt_set = set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}

#define SWIG_init    boot_RNA

#define SWIG_name   "RNA::boot_RNA"
#define SWIG_varinit "RNA::var_RNA_init();"
#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
SWIGEXPORT(void) boot_RNA(CV* cv);
#else
SWIGEXPORT(void) boot_RNA(CV *cv, CPerlObj *);
#endif

#include  "../H/utils.h"
#include  "../H/fold_vars.h"
#undef fold
#include  "../H/fold.h"
#include  "../H/part_func.h"
#include  "../H/PS_dot.h"
#include  "../H/inverse.h"
#include  "../H/RNAstruct.h"
#include  "../H/treedist.h"
#include  "../H/stringdist.h"
#include  "../H/profiledist.h"
#include  "../H/dist_vars.h"
#include  "../H/pair_mat.h"
#ifndef PERL_OBJECT
#define swig_setnv(a,b) _swig_setnv(a,b)
static void _swig_setnv(char *name, double value) { 
#else
#define swig_setnv(a,b) _swig_setnv(pPerl,a,b)
static void _swig_setnv(CPerlObj *pPerl, char *name, double value) { 
#endif
     SV *sv; 
     sv = perl_get_sv(name,TRUE | 0x2);
     sv_setnv(sv, value);
     SvREADONLY_on(sv);
}

extern float fold(char *,char *);
extern float energy_of_struct(char *,char *);
extern void free_arrays();
extern void initialize_fold(int );
extern void update_fold_params();
extern float pf_fold(char *,char *);
extern void init_pf_fold(int );
extern void free_pf_arrays();
extern void update_pf_params(int );
extern char bppm_symbol(float *);
extern char * symbolset; 
extern float inverse_fold(char *,char *);
extern float inverse_pf_fold(char *,char *);
extern float  final_cost; 
extern int  give_up; 
extern double * pr; 
extern int  noGU; 
extern int  no_closingGU; 
extern int  tetra_loop; 
extern int  energy_set; 
extern int  dangles; 
extern char * nonstandards; 
extern double  temperature; 
extern int  james_rule; 
extern int  logML; 
extern struct bond * base_pair; 
extern int * iindx; 
extern double  pf_scale; 
extern int  fold_constrained; 
extern int  do_backtrack; 
extern int  noLonelyPairs; 
extern char  backtrack_type; 

double get_pr(int i, int j) {
   int ii;
  if (i>j) {ii=i; i=j; j=ii;}
  return pr[iindx[i]-j];
}
extern Tree *make_tree(char *);
extern float tree_edit_distance(Tree *,Tree *);
extern void print_tree(Tree *);
extern void free_tree(Tree *);
extern swString *Make_swString(char *);
extern float string_edit_distance(swString *,swString *);
extern float **Make_bp_profile(int );
extern float profile_edit_distance(float **,float **);
extern void print_bppm(float **);
extern void free_profile(float **);
extern int PS_rna_plot(char *,char *,char *);
extern int gmlRNA(char *,char *,char *,char );
extern int ssv_rna_plot(char *,char *,char *);
extern int xrna_plot(char *,char *,char *);
extern int PS_dot_plot(char *,char *);
extern int  rna_plot_type; 
extern void read_parameter_file(const char []);
extern void write_parameter_file(const char []);


#ifdef WIN32
#undef isspace
#define isspace(c) (c == ' ')
#endif

/*------------------------------------------------------------------
  ptrcast(value,type)

  Constructs a new pointer value.   Value may either be a string
  or an integer. Type is a string corresponding to either the
  C datatype or mangled datatype.

  ptrcast(0,"Vector *")
               or
  ptrcast(0,"Vector_p")   
  ------------------------------------------------------------------ */
#ifdef PERL_OBJECT
static SV *_ptrcast(CPerlObj *pPerl, SV *_PTRVALUE, char *type) {
#define ptrcast(a,b)  _ptrcast(pPerl,a,b)
#else
static SV *_ptrcast(SV *_PTRVALUE, char *type) {
#define ptrcast(a,b)  _ptrcast(a,b)
#endif
  char *r,*s;
  void *ptr;
  SV *obj;
  char *typestr,*c;

  /* Produce a "mangled" version of the type string.  */

  typestr = (char *) malloc(strlen(type)+20);

  /* Go through and munge the typestring */
  
  r = typestr;
  c = type;
  while (*c) {
    if (!isspace(*c)) {
      if ((*c == '*') || (*c == '&')) {
	strcpy(r,"Ptr");
	r+=3;
      } else *(r++) = *c;
    } 
    c++;
  }
  *(r++) = 0;
    
  /* Check to see if the input value is an integer */
  if (SvIOK(_PTRVALUE)) {
    ptr = (void *) SvIV(_PTRVALUE);
    /* Received a numerical value. Make a pointer out of it */
    obj = sv_newmortal();
    sv_setref_pv(obj,typestr,ptr);
  } else if (sv_isobject(_PTRVALUE)) {
    /* Have a real pointer value now.  Try to strip out the pointer value */
    /* Now extract the pointer value */
    if (!SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
      obj = sv_newmortal();
      sv_setref_pv(obj,typestr,ptr);
    }
  } else {
    croak("ptrcast(). Not a reference.");
  }
  free(typestr);
  return obj;
}



/*------------------------------------------------------------------
  ptrvalue(ptr,type = 0)

  Attempts to dereference a pointer value.  If type is given, it 
  will try to use that type.  Otherwise, this function will attempt
  to "guess" the proper datatype by checking against all of the 
  builtin C datatypes. 
  ------------------------------------------------------------------ */

#ifdef PERL_OBJECT
static SV *_ptrvalue(CPerlObj *pPerl,SV *_PTRVALUE, int index, char *type) {
#define ptrvalue(a,b,c) _ptrvalue(pPerl,a,b,c)
#else
static SV *_ptrvalue(SV *_PTRVALUE, int index, char *type) {
#define ptrvalue(a,b,c) _ptrvalue(a,b,c)
#endif

  void     *ptr;
  SV       *obj = 0;


  if (SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
    croak("Type error it ptrvalue. Argument is not a valid pointer value.");
  } else {
    /* If no datatype was passed, try a few common datatypes first */
    if (!type) {

      /* No datatype was passed.   Type to figure out if it's a common one */
      
      if (!SWIG_GetPtr(_PTRVALUE,&ptr,"intPtr")) {
	type = "int";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"doublePtr")) {
	type = "double";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"shortPtr")) {
	type = "short";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"longPtr")) {
	type = "long";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"floatPtr")) {
	type = "float";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtr")) {
	type = "char";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtrPtr")) {
	type = "char *";
      } else {
	type = "unknown";
      }
    }
    
    if (!ptr) {
      croak("Unable to dereference NULL pointer.");
      return 0;
    }

    /* Now we have a datatype.  Try to figure out what to do about it */
    if (strcmp(type,"int") == 0) {
      obj = sv_newmortal();
      sv_setiv(obj,(IV) *(((int *) ptr) + index));
    } else if (strcmp(type,"double") == 0) {
      obj = sv_newmortal();
      sv_setnv(obj,(double) *(((double *) ptr)+index));
    } else if (strcmp(type,"short") == 0) {
      obj = sv_newmortal();
      sv_setiv(obj,(IV) *(((short *) ptr) + index));
    } else if (strcmp(type,"long") == 0) {
      obj = sv_newmortal();
      sv_setiv(obj,(IV) *(((long *) ptr) + index));
    } else if (strcmp(type,"float") == 0) {
      obj = sv_newmortal();
      sv_setnv(obj,(double) *(((float *) ptr)+index));
    } else if (strcmp(type,"char") == 0) {
      obj = sv_newmortal();
      sv_setpv(obj,((char *) ptr)+index);
    } else if (strcmp(type,"char *") == 0) {
      char *c = *(((char **) ptr)+index);
      obj = sv_newmortal();
      if (c) 
	sv_setpv(obj,c);
      else 
	sv_setpv(obj,"NULL");
    } else {
      croak("Unable to dereference unsupported datatype.");
      obj = 0;
    }
  }
  return obj;
}

/*------------------------------------------------------------------
  ptrcreate(type,value = 0,numelements = 1)

  Attempts to create a new object of given type.  Type must be
  a basic C datatype.  Will not create complex objects.
  ------------------------------------------------------------------ */
#ifdef PERL_OBJECT
static SV *_ptrcreate(CPerlObj *pPerl, char *type, SV *value, int numelements) {
#define ptrcreate(a,b,c) _ptrcreate(pPerl,a,b,c)
#else
static SV *_ptrcreate(char *type, SV *value, int numelements) {
#define ptrcreate(a,b,c) _ptrcreate(a,b,c)
#endif

  void     *ptr;
  SV       *obj;
  int       sz;
  char     *cast;
  char      temp[40];

  /* Check the type string against a variety of possibilities */

  if (strcmp(type,"int") == 0) {
    sz = sizeof(int)*numelements;
    cast = "intPtr";
  } else if (strcmp(type,"short") == 0) {
    sz = sizeof(short)*numelements;
    cast = "shortPtr";
  } else if (strcmp(type,"long") == 0) {
    sz = sizeof(long)*numelements;
    cast = "longPtr";
  } else if (strcmp(type,"double") == 0) {
    sz = sizeof(double)*numelements;
    cast = "doublePtr";
  } else if (strcmp(type,"float") == 0) {
    sz = sizeof(float)*numelements;
    cast = "floatPtr";
  } else if (strcmp(type,"char") == 0) {
    sz = sizeof(char)*numelements;
    cast = "charPtr";
  } else if (strcmp(type,"char *") == 0) {
    sz = sizeof(char *)*(numelements+1);
    cast = "charPtrPtr";
  } else if (strcmp(type,"void") == 0) {
    sz = numelements;
    cast = "voidPtr";
  } else {
    croak("Unable to create unknown datatype."); 
    return 0;
  }
   
  /* Create the new object */
  
  ptr = (void *) malloc(sz);
  if (!ptr) {
    croak("Out of memory in ptrcreate."); 
    return 0;
  }

  /* Now try to set its default value */

  if (value) {
    if (strcmp(type,"int") == 0) {
      int *ip,i,ivalue;
      ivalue = (int) SvIV(value);
      ip = (int *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"short") == 0) {
      short *ip,ivalue;
      int i;
      ivalue = (short) SvIV(value);
      ip = (short *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"long") == 0) {
      long *ip,ivalue;
      int i;
      ivalue = (long) SvIV(value);
      ip = (long *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"double") == 0) {
      double *ip,ivalue;
      int i;
      ivalue = (double) SvNV(value);
      ip = (double *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"float") == 0) {
      float *ip,ivalue;
      int i;
      ivalue = (float) SvNV(value);
      ip = (float *) ptr;
      for (i = 0; i < numelements; i++)
	ip[i] = ivalue;
    } else if (strcmp(type,"char") == 0) {
      char *ip,*ivalue;
      ivalue = (char *) SvPV(value,PL_na);
      ip = (char *) ptr;
      strncpy(ip,ivalue,numelements-1);
    } else if (strcmp(type,"char *") == 0) {
      char **ip, *ivalue;
      int  i;
      ivalue = (char *) SvPV(value,PL_na);
      ip = (char **) ptr;
      for (i = 0; i < numelements; i++) {
	if (ivalue) {
	  ip[i] = (char *) malloc(strlen(ivalue)+1);
	  strcpy(ip[i],ivalue);
	} else {
	  ip[i] = 0;
	}
      }
      ip[numelements] = 0;
    }
  } 
  /* Create the pointer value */
  
  SWIG_MakePtr(temp,ptr,cast);
  obj = sv_newmortal();
  sv_setref_pv(obj,cast,ptr);
  return obj;
}

/*------------------------------------------------------------------
  ptrset(ptr,value,index = 0,type = 0)

  Attempts to set the value of a pointer variable.  If type is
  given, we will use that type.  Otherwise, we'll guess the datatype.
  ------------------------------------------------------------------ */

#ifdef PERL_OBJECT
static void _ptrset(CPerlObj *pPerl,SV *_PTRVALUE, SV *value, int index, char *type) {
#define ptrset(a,b,c,d) _ptrset(pPerl,a,b,c,d)
#else
static void _ptrset(SV *_PTRVALUE, SV *value, int index, char *type) {
#define ptrset(a,b,c,d) _ptrset(a,b,c,d)
#endif
  void     *ptr;
  SV       *obj;

  if (SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
    croak("Type error in ptrset. Argument is not a valid pointer value.");
    return;
  }

  /* If no datatype was passed, try a few common datatypes first */

  if (!type) {

    /* No datatype was passed.   Type to figure out if it's a common one */

    if (!SWIG_GetPtr(_PTRVALUE,&ptr,"intPtr")) {
      type = "int";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"doublePtr")) {
      type = "double";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"shortPtr")) {
      type = "short";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"longPtr")) {
      type = "long";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"floatPtr")) {
      type = "float";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtr")) {
      type = "char";
    } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtrPtr")) {
      type = "char *";
    } else {
      type = "unknown";
    }
  }

  if (!ptr) {
    croak("Unable to set NULL pointer.");
    return;
  }
  
  /* Now we have a datatype.  Try to figure out what to do about it */
  if (strcmp(type,"int") == 0) {
    *(((int *) ptr)+index) = (int) SvIV(value);
  } else if (strcmp(type,"double") == 0) {
    *(((double *) ptr)+index) = (double) SvNV(value);
  } else if (strcmp(type,"short") == 0) {
    *(((short *) ptr)+index) = (short) SvIV(value);
  } else if (strcmp(type,"long") == 0) {
    *(((long *) ptr)+index) = (long) SvIV(value);
  } else if (strcmp(type,"float") == 0) {
    *(((float *) ptr)+index) = (float) SvNV(value);
  } else if (strcmp(type,"char") == 0) {
    char *c = SvPV(value,PL_na);
    strcpy(((char *) ptr)+index, c);
  } else if (strcmp(type,"char *") == 0) {
    char *c = SvPV(value,PL_na);
    char **ca = (char **) ptr;
    if (ca[index]) free(ca[index]);
    if (strcmp(c,"NULL") == 0) {
      ca[index] = 0;
    } else {
      ca[index] = (char *) malloc(strlen(c)+1);
      strcpy(ca[index],c);
    }
  } else {
    croak("Unable to set unsupported datatype.");
    return;
  }
}

/*------------------------------------------------------------------
  ptradd(ptr,offset)

  Adds a value to an existing pointer value.  Will do a type-dependent
  add for basic datatypes.  For other datatypes, will do a byte-add.
  ------------------------------------------------------------------ */

#ifdef PERL_OBJECT
static SV *_ptradd(CPerlObj *pPerl, SV *_PTRVALUE, int offset) {
#define ptradd(a,b) _ptradd(pPerl,a,b)
#else
static SV *_ptradd(SV *_PTRVALUE, int offset) {
#define ptradd(a,b) _ptradd(a,b)
#endif

  void *ptr,*junk;
  SV   *obj;
  char *type;

  /* Try to handle a few common datatypes first */

  if (!SWIG_GetPtr(_PTRVALUE,&ptr,"intPtr")) {
    ptr = (void *) (((int *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"doublePtr")) {
    ptr = (void *) (((double *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"shortPtr")) {
    ptr = (void *) (((short *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"longPtr")) {
    ptr = (void *) (((long *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"floatPtr")) {
    ptr = (void *) (((float *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtr")) {
    ptr = (void *) (((char *) ptr) + offset);
  } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
    ptr = (void *) (((char *) ptr) + offset);
  } else {
    croak("Type error in ptradd. Argument is not a valid pointer value.");
    return 0;
  }
  type = SWIG_GetPtr(_PTRVALUE,&junk,"INVALID POINTER");
  obj = sv_newmortal();
  sv_setref_pv(obj,type,ptr);
  return obj;
}

/*------------------------------------------------------------------
  ptrmap(type1,type2)

  Allows a mapping between type1 and type2. (Like a typedef)
  ------------------------------------------------------------------ */

#ifdef PERL_OBJECT
static void _ptrmap(CPerlObj *pPerl,char *type1, char *type2) {
#define ptrmap(a,b) _ptrmap(pPerl,a,b)
#else
static void _ptrmap(char *type1, char *type2) {
#define ptrmap(a,b) _ptrmap(a,b)
#endif
  char *typestr1,*typestr2,*c,*r;
  /* Produce a "mangled" version of the type string.  */

  typestr1 = (char *) malloc(strlen(type1)+20);


  /* Go through and munge the typestring */
  
  r = typestr1;
  *(r++) = '_';
  c = type1;

  while (*c) {
    if (!isspace(*c)) {
      if ((*c == '*') || (*c == '&')) {
	strcpy(r,"Ptr");
	r+=3;
      }
      else *(r++) = *c;
    } 
    c++;
  }
  *(r++) = 0;

  typestr2 = (char *) malloc(strlen(type2)+20);

  /* Go through and munge the typestring */
  
  r = typestr2;
  *(r++) = '_';
  c = type2;
  while (*c) {
    if (!isspace(*c)) {
      if ((*c == '*') || (*c == '&')) {
	strcpy(r,"Ptr");
	r+=3;
      }
      else *(r++) = *c;
    }
    c++;
  }
  *(r++) = 0;
  SWIG_RegisterMapping(typestr1,typestr2,0);
  SWIG_RegisterMapping(typestr2,typestr1,0);
}

/*------------------------------------------------------------------
  ptrfree(ptr)

  Destroys a pointer value
  ------------------------------------------------------------------ */
#ifdef PERL_OBJECT
void _ptrfree(CPerlObj *pPerl, SV *_PTRVALUE) {
#define ptrfree(a) _ptrfree(pPerl, a)
#else
void _ptrfree(SV *_PTRVALUE) {
#define ptrfree(a) _ptrfree(a)
#endif

  void *ptr, *junk;

  if (SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
    croak("Type error in ptrfree. Argument is not a valid pointer value.");
    return;
  }

  /* Check to see if this pointer is a char ** */
  if (!SWIG_GetPtr(_PTRVALUE,&junk,"charPtrPtr")) {
    char **c = (char **) ptr;
    if (c) {
      int i = 0;
      while (c[i]) {
	free(c[i]);
	i++;
      }
    }
  } 
  if (ptr)
    free((char *) ptr);
}


void *deref_any(void **ptr, int index) {
   /* dereference arbitray pointer */
   return (void *) ptr[index];
}


#ifdef WIN32
#undef isspace
#define isspace(c) (c == ' ')
#endif



/*------------------------------------------------------------------
  ptr2array(ptr,index,len,type = 0)

  Attempts to dereference a pointer value.  If type is given, it 
  will try to use that type.  Otherwise, this function will attempt
  to "guess" the proper datatype by checking against all of the 
  builtin C datatypes. 
  ------------------------------------------------------------------ */

#ifdef PERL_OBJECT
static AV *_ptr2array(CPerlObj *pPerl,SV *_PTRVALUE, int index, int len, char *type) {
#define ptr2array(a,b,c,d) _ptr2array(pPerl,a,b,c,d)
#else
static AV *_ptr2array(SV *_PTRVALUE, int index, int len, char *type) {
#define ptr2array(a,b,c,d) _ptr2array(a,b,c,d)
#endif

  void     *ptr;
  SV *obj;
  SV      **svs = 0;
  AV        *av = 0;

  int i;
  
  svs = (SV **) malloc(len*sizeof(SV *));
  for (i=0; i<len; i++)
    svs[i] = sv_newmortal();
  
  if (SWIG_GetPtr(_PTRVALUE,&ptr,0)) {
    croak("Type error it ptrvalue. Argument is not a valid pointer value.");
  } else {
    /* If no datatype was passed, try a few common datatypes first */
    if (!type) {

      /* No datatype was passed.   Type to figure out if it's a common one */
      
      if (!SWIG_GetPtr(_PTRVALUE,&ptr,"intPtr")) {
	type = "int";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"doublePtr")) {
	type = "double";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"shortPtr")) {
	type = "short";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"longPtr")) {
	type = "long";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"floatPtr")) {
	type = "float";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtr")) {
	type = "char";
      } else if (!SWIG_GetPtr(_PTRVALUE,&ptr,"charPtrPtr")) {
	type = "char *";
      } else {
	type = "unknown";
      }
    }
    
    if (!ptr) {
      croak("Unable to dereference NULL pointer.");
      return 0;
    }

    /* Now we have a datatype.  Try to figure out what to do about it */
    if (strcmp(type,"int") == 0) {
      for (i = 0; i < len; ++i) 
	sv_setiv(svs[i], (IV) *(((int *) ptr) + index+i));
    } else if (strcmp(type,"double") == 0) {
      for (i = 0; i < len; ++i) 
	sv_setnv(svs[i], (double) *(((double *) ptr) + index+i));
    } else if (strcmp(type,"short") == 0) {
      for (i = 0; i < len; ++i) 
	sv_setiv(svs[i],(IV) *(((short *) ptr) + index+i));
    } else if (strcmp(type,"long") == 0) {
      for (i = 0; i < len; ++i) 
	sv_setiv(svs[i],(IV) *(((long *) ptr) + index+i));
    } else if (strcmp(type,"float") == 0) {
      for (i = 0; i < len; ++i) 
	sv_setnv(svs[i],(double) *(((float *) ptr)+index+i));
    } else if (strcmp(type,"char") == 0) {
      for (i = 0; i < len; ++i) 
	sv_setpv(svs[i],((char *) ptr)+index+i);
    } else if (strcmp(type,"char *") == 0) {
      for (i = 0; i < len; ++i) {
	char *c = *(((char **) ptr)+index+i);
	if (c) 
	  sv_setpv(svs[i],c);
	else 
	  sv_setpv(svs[i],"NULL");
      }
    } else {
      croak("Unable to dereference unsupported datatype.");
      len = 0;
    }
  }

  av = av_make(len,svs);
  free(svs);
  return av;
}


  short *make_loop_index(const char *structure) {
  /* number each position by which loop it belongs to (positions start at 0) */
    int i,j,hx,l,nl;
    int length;
    short *stack;
    short *loop;
    length = strlen(structure);
    stack = (short *) space(sizeof(short)*(length+1));
    loop = (short *) space(sizeof(short)*(length+2));
    hx=l=nl=0;
    for (i=0; i<length; i++) {
      if (structure[i] == '(') {
	nl++; l=nl;
	stack[hx++]=i;
      }
      loop[i]=l;
      if (structure[i] ==')') {
	--hx;
	if (hx>0) 
	  l = loop[stack[hx-1]];  /* index of enclosing loop   */
	else l=0;                 /* external loop has index 0 */
	if (hx<0) {
	  fprintf(stderr, "%s\n", structure);
	  nrerror("unbalanced brackets in make_pair_table");
	}
      }
    }
    free(stack);
    return loop;
  }

float energy_of_move(const char *string, char *structure, int mi, int mj) {
  extern int energy_of_struct_pt(const char *string, short * ptable,
				 short *s, short *s1);
#define ILLEGAL 999.;
  int i,j,hx,l,nl;
  int length;
  short *stack, *table, *loop;
  short *S, *S1;
  int energy;

  if (mj<0) {
    if ((structure[-mi]!='(') || (structure[-mj]!=')')) 
      return 1001;  /* illegal delete pair */
  } else
    if ((structure[mi]!='.') || (structure[mj]!='.'))
      return 1002;  /* illegal add pair */
  
  /* make the pair table and loop index l*/
  length = strlen(structure);
  stack = (short *) space(sizeof(short)*(length+1));
  loop  = (short *) space(sizeof(short)*(length+2));
  table = (short *) space(sizeof(short)*(length+2));
  table[0] = length;
  hx=l=nl=0;
  for (i=1; i<=length; i++) {
    if (structure[i-1] == '(') {
      nl++; l=nl;
      stack[hx++]=i;
    }
    loop[i]=l;
    if (structure[i-1] ==')') {
      j=stack[--hx];
      if (hx>0) 
	l = loop[stack[hx-1]];  /* index of enclosing loop   */
      else l=0;                 /* external loop has index 0 */
      if (hx<0) {
	fprintf(stderr, "%s\n", structure);
	nrerror("unbalanced brackets in energy_of_move");
      }
      table[i]=j;
      table[j]=i;
    }
  }
  if (hx!=0) {
    fprintf(stderr, "%s\n", structure);
    nrerror("unbalanced brackets in energy_of_move");
  }

  if (loop[abs(mi)+1] != loop[abs(mj)+1]) { /* not in same loop => illegal */
    free(stack);
    free(loop);
    free(table);
    return 1003.;
  }

  /* if we get here the move is legal */
  if (mj<0) { /* delete pair */
    structure[-mi] = '.';
    structure[-mj] = '.';
    table[-mi+1] = table[-mj+1] = 0;
  } else { /* insert pair */
    structure[mi] = '(';
    structure[mj] = ')';
    table[mi+1] = mj+1;
    table[mj+1] = mi+1;
  }

  S = (short *) space(sizeof(short)*(length+1));
  S[0] = length;
  for (i=1; i<=length; i++) {
    char *pos;
    pos = strchr(Law_and_Order, string[i-1]);
    if (pos==NULL) S[i]=0;
    else S[i] = pos-Law_and_Order;
  }
  
  energy =  energy_of_struct_pt(string, table, S, S);

  free(S); 
  free(stack);
  free(loop);
  free(table);
  return (float) energy/100.;
}
#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_RNA_var::
class _wrap_RNA_var : public CPerlObj {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}
SWIGCLASS_STATIC int _wrap_set_symbolset(SV* sv, MAGIC *mg) {

    char *_a;

    MAGIC_PPERL
    mg = mg;
    _a = (char *) SvPV(sv,PL_na);
    if (symbolset) free(symbolset);
    symbolset = (char *) malloc(strlen(_a)+1);
strcpy(symbolset,_a);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_symbolset(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setpv((SV*) sv, symbolset);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_final_cost(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    final_cost = (float ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_final_cost(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) final_cost);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_give_up(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    give_up = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_give_up(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) give_up);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_pr(SV* sv, MAGIC *mg) {

    void *_temp;

    MAGIC_PPERL
    mg = mg;
    if (SWIG_GetPtr(sv,(void **) &_temp,"doublePtr")) {
        croak("Type error in value of pr. Expected doublePtr.");
        return(1);
    }
    pr = (double *) _temp;
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_pr(SV *sv, MAGIC *mg) {

    SV *rsv;

    MAGIC_PPERL
    mg = mg;
    rsv = SvRV(sv);
    sv_setiv(rsv,(IV) pr);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_noGU(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    noGU = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_noGU(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) noGU);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_no_closingGU(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    no_closingGU = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_no_closingGU(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) no_closingGU);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_tetra_loop(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    tetra_loop = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_tetra_loop(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) tetra_loop);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_energy_set(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    energy_set = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_energy_set(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) energy_set);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_dangles(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    dangles = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_dangles(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) dangles);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_nonstandards(SV* sv, MAGIC *mg) {

    char *_a;

    MAGIC_PPERL
    mg = mg;
    _a = (char *) SvPV(sv,PL_na);
    if (nonstandards) free(nonstandards);
    nonstandards = (char *) malloc(strlen(_a)+1);
strcpy(nonstandards,_a);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_nonstandards(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setpv((SV*) sv, nonstandards);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_temperature(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    temperature = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_temperature(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) temperature);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_james_rule(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    james_rule = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_james_rule(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) james_rule);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_logML(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    logML = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_logML(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) logML);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_base_pair(SV* sv, MAGIC *mg) {

    void *_temp;

    MAGIC_PPERL
    mg = mg;
    if (SWIG_GetPtr(sv,(void **) &_temp,"struct bondPtr")) {
        croak("Type error in value of base_pair. Expected struct bondPtr.");
        return(1);
    }
    base_pair = (struct bond *) _temp;
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_base_pair(SV *sv, MAGIC *mg) {

    SV *rsv;

    MAGIC_PPERL
    mg = mg;
    rsv = SvRV(sv);
    sv_setiv(rsv,(IV) base_pair);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_iindx(SV* sv, MAGIC *mg) {

    void *_temp;

    MAGIC_PPERL
    mg = mg;
    if (SWIG_GetPtr(sv,(void **) &_temp,"intPtr")) {
        croak("Type error in value of iindx. Expected intPtr.");
        return(1);
    }
    iindx = (int *) _temp;
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_iindx(SV *sv, MAGIC *mg) {

    SV *rsv;

    MAGIC_PPERL
    mg = mg;
    rsv = SvRV(sv);
    sv_setiv(rsv,(IV) iindx);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_pf_scale(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    pf_scale = (double ) SvNV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_pf_scale(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setnv(sv, (double) pf_scale);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_fold_constrained(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    fold_constrained = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_fold_constrained(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) fold_constrained);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_do_backtrack(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    do_backtrack = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_do_backtrack(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) do_backtrack);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_noLonelyPairs(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    noLonelyPairs = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_noLonelyPairs(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) noLonelyPairs);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_backtrack_type(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    backtrack_type = (char) *SvPV(sv,PL_na);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_backtrack_type(SV *sv, MAGIC *mg) {

    char _ptemp[2];

    MAGIC_PPERL
    mg = mg;
    _ptemp[0] = backtrack_type;
    _ptemp[1] = 0;
    sv_setpv((SV*) sv, _ptemp);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_loop_size(SV *sv, MAGIC *mg) {

    SV *rsv;

    MAGIC_PPERL
    mg = mg;
    rsv = SvRV(sv);
    sv_setiv(rsv,(IV) loop_size);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_helix_size(SV *sv, MAGIC *mg) {

    SV *rsv;

    MAGIC_PPERL
    mg = mg;
    rsv = SvRV(sv);
    sv_setiv(rsv,(IV) helix_size);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_loop_degree(SV *sv, MAGIC *mg) {

    SV *rsv;

    MAGIC_PPERL
    mg = mg;
    rsv = SvRV(sv);
    sv_setiv(rsv,(IV) loop_degree);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_loops(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    loops = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_loops(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) loops);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_unpaired(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    unpaired = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_unpaired(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) unpaired);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_pairs(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    pairs = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_pairs(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) pairs);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_edit_backtrack(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    edit_backtrack = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_edit_backtrack(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) edit_backtrack);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_aligned_line(SV *sv, MAGIC *mg) {

    SV *rsv;

    MAGIC_PPERL
    mg = mg;
    rsv = SvRV(sv);
    sv_setiv(rsv,(IV) aligned_line);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_cost_matrix(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    cost_matrix = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_cost_matrix(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) cost_matrix);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_xsubi(SV *sv, MAGIC *mg) {

    SV *rsv;

    MAGIC_PPERL
    mg = mg;
    rsv = SvRV(sv);
    sv_setiv(rsv,(IV) xsubi);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_rna_plot_type(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    rna_plot_type = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_rna_plot_type(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) rna_plot_type);
    return 1;
}



#ifdef PERL_OBJECT
};
#endif

XS(_wrap_fold) {

    float  _result;
    char * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: fold(sequence,structure);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    _result = (float )fold(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_energy_of_struct) {

    float  _result;
    char * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: energy_of_struct(string,structure);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    _result = (float )energy_of_struct(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_free_arrays) {

    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: free_arrays();");
    free_arrays();
    XSRETURN(argvi);
}

XS(_wrap_initialize_fold) {

    int  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: initialize_fold(length);");
    _arg0 = (int )SvIV(ST(0));
    initialize_fold(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_update_fold_params) {

    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: update_fold_params();");
    update_fold_params();
    XSRETURN(argvi);
}

XS(_wrap_pf_fold) {

    float  _result;
    char * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: pf_fold(sequence,structure);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    _result = (float )pf_fold(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_init_pf_fold) {

    int  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: init_pf_fold(length);");
    _arg0 = (int )SvIV(ST(0));
    init_pf_fold(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_free_pf_arrays) {

    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: free_pf_arrays();");
    free_pf_arrays();
    XSRETURN(argvi);
}

XS(_wrap_update_pf_params) {

    int  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: update_pf_params(length);");
    _arg0 = (int )SvIV(ST(0));
    update_pf_params(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_bppm_symbol) {

    char  _result;
    float * _arg0;
    int argvi = 0;
    char _ctemp[2];
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: bppm_symbol(x);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"floatPtr")) {
        croak("Type error in argument 1 of bppm_symbol. Expected floatPtr.");
        XSRETURN(1);
    }
    _result = (char )bppm_symbol(_arg0);
    ST(argvi) = sv_newmortal();
    _ctemp[0] = _result;
    _ctemp[1] = 0;
    sv_setpv((SV*)ST(argvi++),_ctemp);
    XSRETURN(argvi);
}

XS(_wrap_inverse_fold) {

    float  _result;
    char * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: inverse_fold(start,target);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    _result = (float )inverse_fold(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_inverse_pf_fold) {

    float  _result;
    char * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: inverse_pf_fold(start,target);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    _result = (float )inverse_pf_fold(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_option_string) {

    char * _result;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: option_string();");
    _result = (char *)option_string();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_get_pr) {

    double  _result;
    int  _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: get_pr(i,j);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _result = (double )get_pr(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_b2HIT) {

    char * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: b2HIT(structure);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (char *)b2HIT(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
free(_result);

    XSRETURN(argvi);
}

XS(_wrap_b2C) {

    char * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: b2C(structure);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (char *)b2C(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
free(_result);

    XSRETURN(argvi);
}

XS(_wrap_b2Shapiro) {

    char * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: b2Shapiro(structure);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (char *)b2Shapiro(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
free(_result);

    XSRETURN(argvi);
}

XS(_wrap_add_root) {

    char * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: add_root(char *);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (char *)add_root(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
free(_result);

    XSRETURN(argvi);
}

XS(_wrap_expand_Shapiro) {

    char * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: expand_Shapiro(coarse);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (char *)expand_Shapiro(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
free(_result);

    XSRETURN(argvi);
}

XS(_wrap_expand_Full) {

    char * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: expand_Full(structure);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (char *)expand_Full(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
free(_result);

    XSRETURN(argvi);
}

XS(_wrap_unexpand_Full) {

    char * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: unexpand_Full(ffull);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (char *)unexpand_Full(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
free(_result);

    XSRETURN(argvi);
}

XS(_wrap_unweight) {

    char * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: unweight(wcoarse);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (char *)unweight(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
free(_result);

    XSRETURN(argvi);
}

XS(_wrap_unexpand_aligned_F) {

    char ** _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: unexpand_aligned_F(align);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"charPtrPtr")) {
        croak("Type error in argument 1 of unexpand_aligned_F. Expected charPtrPtr.");
        XSRETURN(1);
    }
    unexpand_aligned_F(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_parse_structure) {

    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: parse_structure(structure);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    parse_structure(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_make_tree) {

    Tree * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: make_tree(struc);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (Tree *)make_tree(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"TreePtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_tree_edit_distance) {

    float  _result;
    Tree * _arg0;
    Tree * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: tree_edit_distance(T1,T2);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"TreePtr")) {
        croak("Type error in argument 1 of tree_edit_distance. Expected TreePtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"TreePtr")) {
        croak("Type error in argument 2 of tree_edit_distance. Expected TreePtr.");
        XSRETURN(1);
    }
    _result = (float )tree_edit_distance(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_print_tree) {

    Tree * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: print_tree(t);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"TreePtr")) {
        croak("Type error in argument 1 of print_tree. Expected TreePtr.");
        XSRETURN(1);
    }
    print_tree(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_free_tree) {

    Tree * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: free_tree(t);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"TreePtr")) {
        croak("Type error in argument 1 of free_tree. Expected TreePtr.");
        XSRETURN(1);
    }
    free_tree(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_Make_swString) {

    swString * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: Make_swString(string);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (swString *)Make_swString(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"swStringPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_string_edit_distance) {

    float  _result;
    swString * _arg0;
    swString * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: string_edit_distance(T1,T2);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"swStringPtr")) {
        croak("Type error in argument 1 of string_edit_distance. Expected swStringPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"swStringPtr")) {
        croak("Type error in argument 2 of string_edit_distance. Expected swStringPtr.");
        XSRETURN(1);
    }
    _result = (float )string_edit_distance(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_Make_bp_profile) {

    float ** _result;
    int  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: Make_bp_profile(length);");
    _arg0 = (int )SvIV(ST(0));
    _result = (float **)Make_bp_profile(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"floatPtrPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_profile_edit_distance) {

    float  _result;
    float ** _arg0;
    float ** _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: profile_edit_distance(T1,T2);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"floatPtrPtr")) {
        croak("Type error in argument 1 of profile_edit_distance. Expected floatPtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"floatPtrPtr")) {
        croak("Type error in argument 2 of profile_edit_distance. Expected floatPtrPtr.");
        XSRETURN(1);
    }
    _result = (float )profile_edit_distance(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_print_bppm) {

    float ** _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: print_bppm(T);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"floatPtrPtr")) {
        croak("Type error in argument 1 of print_bppm. Expected floatPtrPtr.");
        XSRETURN(1);
    }
    print_bppm(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_free_profile) {

    float ** _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: free_profile(T);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"floatPtrPtr")) {
        croak("Type error in argument 1 of free_profile. Expected floatPtrPtr.");
        XSRETURN(1);
    }
    free_profile(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_space) {

    void * _result;
    unsigned  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: space(size);");
    _arg0 = (unsigned )SvIV(ST(0));
    _result = (void *)space(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"voidPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_nrerror) {

    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: nrerror(message);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    nrerror(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_init_rand) {

    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: init_rand();");
    init_rand();
    XSRETURN(argvi);
}

XS(_wrap_urn) {

    double  _result;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: urn();");
    _result = (double )urn();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_int_urn) {

    int  _result;
    int  _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: int_urn(from,to);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _result = (int )int_urn(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_filecopy) {

    FILE * _arg0;
    FILE * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: filecopy(from,to);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"FILEPtr")) {
        croak("Type error in argument 1 of filecopy. Expected FILEPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"FILEPtr")) {
        croak("Type error in argument 2 of filecopy. Expected FILEPtr.");
        XSRETURN(1);
    }
    filecopy(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_time_stamp) {

    char * _result;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: time_stamp();");
    _result = (char *)time_stamp();
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
free(_result);

    XSRETURN(argvi);
}

XS(_wrap_random_string) {

    char * _result;
    int  _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: random_string(l,symbols);");
    _arg0 = (int )SvIV(ST(0));
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    _result = (char *)random_string(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
free(_result);

    XSRETURN(argvi);
}

XS(_wrap_hamming) {

    int  _result;
    char * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: hamming(s1,s2);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    _result = (int )hamming(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_get_line) {

    char * _result;
    FILE * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: get_line(fp);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"FILEPtr")) {
        croak("Type error in argument 1 of get_line. Expected FILEPtr.");
        XSRETURN(1);
    }
    _result = (char *)get_line(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
free(_result);

    XSRETURN(argvi);
}

XS(_wrap_pack_structure) {

    char * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: pack_structure(struc);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (char *)pack_structure(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
free(_result);

    XSRETURN(argvi);
}

XS(_wrap_unpack_structure) {

    char * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: unpack_structure(packed);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (char *)unpack_structure(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
free(_result);

    XSRETURN(argvi);
}

XS(_wrap_make_pair_table) {

    short * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: make_pair_table(structure);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (short *)make_pair_table(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"shortPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_bp_distance) {

    int  _result;
    char * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: bp_distance(str1,str2);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    _result = (int )bp_distance(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_PS_rna_plot) {

    int  _result;
    char * _arg0;
    char * _arg1;
    char * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: PS_rna_plot(string,structure,file);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    if (! SvOK((SV*) ST(2))) { _arg2 = 0; }
    else { _arg2 = (char *) SvPV(ST(2),PL_na); }
    _result = (int )PS_rna_plot(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_gmlRNA) {

    int  _result;
    char * _arg0;
    char * _arg1;
    char * _arg2;
    char  _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: gmlRNA(string,structure,ssfile,option);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    if (! SvOK((SV*) ST(2))) { _arg2 = 0; }
    else { _arg2 = (char *) SvPV(ST(2),PL_na); }
    _arg3 = (char) *SvPV(ST(3),PL_na);
    _result = (int )gmlRNA(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_ssv_rna_plot) {

    int  _result;
    char * _arg0;
    char * _arg1;
    char * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: ssv_rna_plot(string,structure,ssfile);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    if (! SvOK((SV*) ST(2))) { _arg2 = 0; }
    else { _arg2 = (char *) SvPV(ST(2),PL_na); }
    _result = (int )ssv_rna_plot(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_xrna_plot) {

    int  _result;
    char * _arg0;
    char * _arg1;
    char * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: xrna_plot(string,structure,ssfile);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    if (! SvOK((SV*) ST(2))) { _arg2 = 0; }
    else { _arg2 = (char *) SvPV(ST(2),PL_na); }
    _result = (int )xrna_plot(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_PS_dot_plot) {

    int  _result;
    char * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: PS_dot_plot(string,file);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    _result = (int )PS_dot_plot(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_read_parameter_file) {

    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: read_parameter_file(fname);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    read_parameter_file(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_write_parameter_file) {

    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: write_parameter_file(fname);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    write_parameter_file(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_ptrcast) {

    SV * _result;
    SV * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ptrcast(ptr,type);");
{
  _arg0 = ST(0);
}
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    _result = (SV *)ptrcast(_arg0,_arg1);
{
  ST(argvi) = _result;
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ptrvalue) {

    SV * _result;
    SV * _arg0;
    int  _arg1 = (int ) 0;
    char * _arg2 = (char *) 0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 3)) 
        croak("Usage: ptrvalue(ptr,index,type);");
{
  _arg0 = ST(0);
}
    if (items > 1) {
    _arg1 = (int )SvIV(ST(1));
    } 
    if (items > 2) {
    if (! SvOK((SV*) ST(2))) { _arg2 = 0; }
    else { _arg2 = (char *) SvPV(ST(2),PL_na); }
    } 
    _result = (SV *)ptrvalue(_arg0,_arg1,_arg2);
{
  ST(argvi) = _result;
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ptrset) {

    SV * _arg0;
    SV * _arg1;
    int  _arg2 = (int ) 0;
    char * _arg3 = (char *) 0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 4)) 
        croak("Usage: ptrset(ptr,value,index,type);");
{
  _arg0 = ST(0);
}
{
  _arg1 = ST(1);
}
    if (items > 2) {
    _arg2 = (int )SvIV(ST(2));
    } 
    if (items > 3) {
    if (! SvOK((SV*) ST(3))) { _arg3 = 0; }
    else { _arg3 = (char *) SvPV(ST(3),PL_na); }
    } 
    ptrset(_arg0,_arg1,_arg2,_arg3);
    XSRETURN(argvi);
}

XS(_wrap_ptrcreate) {

    SV * _result;
    char * _arg0;
    SV * _arg1 = (SV *) 0;
    int  _arg2 = (int ) 1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 3)) 
        croak("Usage: ptrcreate(type,value,nitems);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (items > 1) {
{
  _arg1 = ST(1);
}
    } 
    if (items > 2) {
    _arg2 = (int )SvIV(ST(2));
    } 
    _result = (SV *)ptrcreate(_arg0,_arg1,_arg2);
{
  ST(argvi) = _result;
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ptrfree) {

    SV * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: ptrfree(ptr);");
{
  _arg0 = ST(0);
}
    ptrfree(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_ptradd) {

    SV * _result;
    SV * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ptradd(ptr,offset);");
{
  _arg0 = ST(0);
}
    _arg1 = (int )SvIV(ST(1));
    _result = (SV *)ptradd(_arg0,_arg1);
{
  ST(argvi) = _result;
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_ptrmap) {

    char * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: ptrmap(type1,type2);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    ptrmap(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_deref_any) {

    void * _result;
    void ** _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: deref_any(ptr,index);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of deref_any. Expected voidPtrPtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (void *)deref_any(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"voidPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_ptr2array) {

    AV * _result;
    SV * _arg0;
    int  _arg1 = (int ) 0;
    int  _arg2 = (int ) 1;
    char * _arg3 = (char *) 0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 4)) 
        croak("Usage: ptr2array(ptr,index,len,type);");
{
  _arg0 = ST(0);
}
    if (items > 1) {
    _arg1 = (int )SvIV(ST(1));
    } 
    if (items > 2) {
    _arg2 = (int )SvIV(ST(2));
    } 
    if (items > 3) {
    if (! SvOK((SV*) ST(3))) { _arg3 = 0; }
    else { _arg3 = (char *) SvPV(ST(3),PL_na); }
    } 
    _result = (AV *)ptr2array(_arg0,_arg1,_arg2,_arg3);
{
  ST(argvi) = newRV_noinc((SV*) _result);
  sv_2mortal(ST(argvi));
  argvi++;
}
    XSRETURN(argvi);
}

XS(_wrap_make_loop_index) {

    short * _result;
    char * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: make_loop_index(structure);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (short *)make_loop_index(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"shortPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_energy_of_move) {

    float  _result;
    char * _arg0;
    char * _arg1;
    int  _arg2;
    int  _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: energy_of_move(string,structure,mi,mj);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    _arg2 = (int )SvIV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _result = (float )energy_of_move(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

#define bond_i_set(_swigobj,_swigval) (_swigobj->i = _swigval,_swigval)
XS(_wrap_bond_i_set) {

    int  _result;
    struct bond * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: bond_i_set(self,i);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct bondPtr")) {
        croak("Type error in argument 1 of bond_i_set. Expected struct bondPtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )bond_i_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define bond_i_get(_swigobj) ((int ) _swigobj->i)
XS(_wrap_bond_i_get) {

    int  _result;
    struct bond * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: bond_i_get(self);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct bondPtr")) {
        croak("Type error in argument 1 of bond_i_get. Expected struct bondPtr.");
        XSRETURN(1);
    }
    _result = (int )bond_i_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define bond_j_set(_swigobj,_swigval) (_swigobj->j = _swigval,_swigval)
XS(_wrap_bond_j_set) {

    int  _result;
    struct bond * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: bond_j_set(self,j);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct bondPtr")) {
        croak("Type error in argument 1 of bond_j_set. Expected struct bondPtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )bond_j_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define bond_j_get(_swigobj) ((int ) _swigobj->j)
XS(_wrap_bond_j_get) {

    int  _result;
    struct bond * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: bond_j_get(self);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"struct bondPtr")) {
        croak("Type error in argument 1 of bond_j_get. Expected struct bondPtr.");
        XSRETURN(1);
    }
    _result = (int )bond_j_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

/*
 * This table is used by the pointer type-checker
 */
static struct { char *n1; char *n2; void *(*pcnv)(void *); } _swig_mapping[] = {
    { "struct bond","bond",0},
    { "bond","struct bond",0},
    { "unsigned short","short",0},
    { "long","unsigned long",0},
    { "long","signed long",0},
    { "signed short","short",0},
    { "signed int","int",0},
    { "short","unsigned short",0},
    { "short","signed short",0},
    { "unsigned long","long",0},
    { "int","unsigned int",0},
    { "int","signed int",0},
    { "unsigned int","int",0},
    { "signed long","long",0},
{0,0,0}};

XS(_wrap_perl5_RNA_var_init) {
    dXSARGS;
    SV *sv;
    cv = cv; items = items;
    swig_setnv("RNA::VERSION", (double) (0.2));
    sv = perl_get_sv("RNA::symbolset",TRUE | 0x2);
    swig_create_magic(sv,"RNA::symbolset", MAGIC_CAST MAGIC_CLASS _wrap_set_symbolset, MAGIC_CAST MAGIC_CLASS _wrap_val_symbolset);
    sv = perl_get_sv("RNA::final_cost",TRUE | 0x2);
    sv_setnv(sv,(double)final_cost);
    swig_create_magic(sv,"RNA::final_cost", MAGIC_CAST MAGIC_CLASS _wrap_set_final_cost, MAGIC_CAST MAGIC_CLASS _wrap_val_final_cost);
    sv = perl_get_sv("RNA::give_up",TRUE | 0x2);
    sv_setiv(sv,(IV)give_up);
    swig_create_magic(sv,"RNA::give_up", MAGIC_CAST MAGIC_CLASS _wrap_set_give_up, MAGIC_CAST MAGIC_CLASS _wrap_val_give_up);
    sv = perl_get_sv("RNA::pr",TRUE | 0x2);
    sv_setref_pv(sv,"doublePtr",(void *) 1);
    swig_create_magic(sv,"RNA::pr", MAGIC_CAST MAGIC_CLASS _wrap_set_pr, MAGIC_CAST MAGIC_CLASS _wrap_val_pr);
    sv = perl_get_sv("RNA::noGU",TRUE | 0x2);
    sv_setiv(sv,(IV)noGU);
    swig_create_magic(sv,"RNA::noGU", MAGIC_CAST MAGIC_CLASS _wrap_set_noGU, MAGIC_CAST MAGIC_CLASS _wrap_val_noGU);
    sv = perl_get_sv("RNA::no_closingGU",TRUE | 0x2);
    sv_setiv(sv,(IV)no_closingGU);
    swig_create_magic(sv,"RNA::no_closingGU", MAGIC_CAST MAGIC_CLASS _wrap_set_no_closingGU, MAGIC_CAST MAGIC_CLASS _wrap_val_no_closingGU);
    sv = perl_get_sv("RNA::tetra_loop",TRUE | 0x2);
    sv_setiv(sv,(IV)tetra_loop);
    swig_create_magic(sv,"RNA::tetra_loop", MAGIC_CAST MAGIC_CLASS _wrap_set_tetra_loop, MAGIC_CAST MAGIC_CLASS _wrap_val_tetra_loop);
    sv = perl_get_sv("RNA::energy_set",TRUE | 0x2);
    sv_setiv(sv,(IV)energy_set);
    swig_create_magic(sv,"RNA::energy_set", MAGIC_CAST MAGIC_CLASS _wrap_set_energy_set, MAGIC_CAST MAGIC_CLASS _wrap_val_energy_set);
    sv = perl_get_sv("RNA::dangles",TRUE | 0x2);
    sv_setiv(sv,(IV)dangles);
    swig_create_magic(sv,"RNA::dangles", MAGIC_CAST MAGIC_CLASS _wrap_set_dangles, MAGIC_CAST MAGIC_CLASS _wrap_val_dangles);
    sv = perl_get_sv("RNA::nonstandards",TRUE | 0x2);
    swig_create_magic(sv,"RNA::nonstandards", MAGIC_CAST MAGIC_CLASS _wrap_set_nonstandards, MAGIC_CAST MAGIC_CLASS _wrap_val_nonstandards);
    sv = perl_get_sv("RNA::temperature",TRUE | 0x2);
    sv_setnv(sv,(double)temperature);
    swig_create_magic(sv,"RNA::temperature", MAGIC_CAST MAGIC_CLASS _wrap_set_temperature, MAGIC_CAST MAGIC_CLASS _wrap_val_temperature);
    sv = perl_get_sv("RNA::james_rule",TRUE | 0x2);
    sv_setiv(sv,(IV)james_rule);
    swig_create_magic(sv,"RNA::james_rule", MAGIC_CAST MAGIC_CLASS _wrap_set_james_rule, MAGIC_CAST MAGIC_CLASS _wrap_val_james_rule);
    sv = perl_get_sv("RNA::logML",TRUE | 0x2);
    sv_setiv(sv,(IV)logML);
    swig_create_magic(sv,"RNA::logML", MAGIC_CAST MAGIC_CLASS _wrap_set_logML, MAGIC_CAST MAGIC_CLASS _wrap_val_logML);
    sv = perl_get_sv("RNA::base_pair",TRUE | 0x2);
    sv_setref_pv(sv,"struct bondPtr",(void *) 1);
    swig_create_magic(sv,"RNA::base_pair", MAGIC_CAST MAGIC_CLASS _wrap_set_base_pair, MAGIC_CAST MAGIC_CLASS _wrap_val_base_pair);
    sv = perl_get_sv("RNA::iindx",TRUE | 0x2);
    sv_setref_pv(sv,"intPtr",(void *) 1);
    swig_create_magic(sv,"RNA::iindx", MAGIC_CAST MAGIC_CLASS _wrap_set_iindx, MAGIC_CAST MAGIC_CLASS _wrap_val_iindx);
    sv = perl_get_sv("RNA::pf_scale",TRUE | 0x2);
    sv_setnv(sv,(double)pf_scale);
    swig_create_magic(sv,"RNA::pf_scale", MAGIC_CAST MAGIC_CLASS _wrap_set_pf_scale, MAGIC_CAST MAGIC_CLASS _wrap_val_pf_scale);
    sv = perl_get_sv("RNA::fold_constrained",TRUE | 0x2);
    sv_setiv(sv,(IV)fold_constrained);
    swig_create_magic(sv,"RNA::fold_constrained", MAGIC_CAST MAGIC_CLASS _wrap_set_fold_constrained, MAGIC_CAST MAGIC_CLASS _wrap_val_fold_constrained);
    sv = perl_get_sv("RNA::do_backtrack",TRUE | 0x2);
    sv_setiv(sv,(IV)do_backtrack);
    swig_create_magic(sv,"RNA::do_backtrack", MAGIC_CAST MAGIC_CLASS _wrap_set_do_backtrack, MAGIC_CAST MAGIC_CLASS _wrap_val_do_backtrack);
    sv = perl_get_sv("RNA::noLonelyPairs",TRUE | 0x2);
    sv_setiv(sv,(IV)noLonelyPairs);
    swig_create_magic(sv,"RNA::noLonelyPairs", MAGIC_CAST MAGIC_CLASS _wrap_set_noLonelyPairs, MAGIC_CAST MAGIC_CLASS _wrap_val_noLonelyPairs);
    sv = perl_get_sv("RNA::backtrack_type",TRUE | 0x2);
    swig_create_magic(sv,"RNA::backtrack_type", MAGIC_CAST MAGIC_CLASS _wrap_set_backtrack_type, MAGIC_CAST MAGIC_CLASS _wrap_val_backtrack_type);
    sv = perl_get_sv("RNA::loop_size",TRUE | 0x2);
    sv_setref_pv(sv,"intPtr",(void *) 1);
    swig_create_magic(sv,"RNA::loop_size",MAGIC_CAST MAGIC_CLASS swig_magic_readonly, MAGIC_CAST MAGIC_CLASS _wrap_val_loop_size);
    sv = perl_get_sv("RNA::helix_size",TRUE | 0x2);
    sv_setref_pv(sv,"intPtr",(void *) 1);
    swig_create_magic(sv,"RNA::helix_size",MAGIC_CAST MAGIC_CLASS swig_magic_readonly, MAGIC_CAST MAGIC_CLASS _wrap_val_helix_size);
    sv = perl_get_sv("RNA::loop_degree",TRUE | 0x2);
    sv_setref_pv(sv,"intPtr",(void *) 1);
    swig_create_magic(sv,"RNA::loop_degree",MAGIC_CAST MAGIC_CLASS swig_magic_readonly, MAGIC_CAST MAGIC_CLASS _wrap_val_loop_degree);
    sv = perl_get_sv("RNA::loops",TRUE | 0x2);
    sv_setiv(sv,(IV)loops);
    swig_create_magic(sv,"RNA::loops", MAGIC_CAST MAGIC_CLASS _wrap_set_loops, MAGIC_CAST MAGIC_CLASS _wrap_val_loops);
    sv = perl_get_sv("RNA::unpaired",TRUE | 0x2);
    sv_setiv(sv,(IV)unpaired);
    swig_create_magic(sv,"RNA::unpaired", MAGIC_CAST MAGIC_CLASS _wrap_set_unpaired, MAGIC_CAST MAGIC_CLASS _wrap_val_unpaired);
    sv = perl_get_sv("RNA::pairs",TRUE | 0x2);
    sv_setiv(sv,(IV)pairs);
    swig_create_magic(sv,"RNA::pairs", MAGIC_CAST MAGIC_CLASS _wrap_set_pairs, MAGIC_CAST MAGIC_CLASS _wrap_val_pairs);
    sv = perl_get_sv("RNA::edit_backtrack",TRUE | 0x2);
    sv_setiv(sv,(IV)edit_backtrack);
    swig_create_magic(sv,"RNA::edit_backtrack", MAGIC_CAST MAGIC_CLASS _wrap_set_edit_backtrack, MAGIC_CAST MAGIC_CLASS _wrap_val_edit_backtrack);
    sv = perl_get_sv("RNA::aligned_line",TRUE | 0x2);
    sv_setref_pv(sv,"charPtrPtr",(void *) 1);
    swig_create_magic(sv,"RNA::aligned_line",MAGIC_CAST MAGIC_CLASS swig_magic_readonly, MAGIC_CAST MAGIC_CLASS _wrap_val_aligned_line);
    sv = perl_get_sv("RNA::cost_matrix",TRUE | 0x2);
    sv_setiv(sv,(IV)cost_matrix);
    swig_create_magic(sv,"RNA::cost_matrix", MAGIC_CAST MAGIC_CLASS _wrap_set_cost_matrix, MAGIC_CAST MAGIC_CLASS _wrap_val_cost_matrix);
    sv = perl_get_sv("RNA::xsubi",TRUE | 0x2);
    sv_setref_pv(sv,"unsigned shortPtr",(void *) 1);
    swig_create_magic(sv,"RNA::xsubi",MAGIC_CAST MAGIC_CLASS swig_magic_readonly, MAGIC_CAST MAGIC_CLASS _wrap_val_xsubi);
    sv = perl_get_sv("RNA::rna_plot_type",TRUE | 0x2);
    sv_setiv(sv,(IV)rna_plot_type);
    swig_create_magic(sv,"RNA::rna_plot_type", MAGIC_CAST MAGIC_CLASS _wrap_set_rna_plot_type, MAGIC_CAST MAGIC_CLASS _wrap_val_rna_plot_type);
    XSRETURN(1);
}
#ifdef __cplusplus
extern "C"
#endif
XS(boot_RNA) {
	 dXSARGS;
	 char *file = __FILE__;
	 cv = cv; items = items;
	 newXS("RNA::var_RNA_init", _wrap_perl5_RNA_var_init, file);
	 newXS("RNA::fold", _wrap_fold, file);
	 newXS("RNA::energy_of_struct", _wrap_energy_of_struct, file);
	 newXS("RNA::free_arrays", _wrap_free_arrays, file);
	 newXS("RNA::initialize_fold", _wrap_initialize_fold, file);
	 newXS("RNA::update_fold_params", _wrap_update_fold_params, file);
	 newXS("RNA::pf_fold", _wrap_pf_fold, file);
	 newXS("RNA::init_pf_fold", _wrap_init_pf_fold, file);
	 newXS("RNA::free_pf_arrays", _wrap_free_pf_arrays, file);
	 newXS("RNA::update_pf_params", _wrap_update_pf_params, file);
	 newXS("RNA::bppm_symbol", _wrap_bppm_symbol, file);
	 newXS("RNA::inverse_fold", _wrap_inverse_fold, file);
	 newXS("RNA::inverse_pf_fold", _wrap_inverse_pf_fold, file);
	 newXS("RNA::option_string", _wrap_option_string, file);
	 newXS("RNA::get_pr", _wrap_get_pr, file);
	 newXS("RNA::b2HIT", _wrap_b2HIT, file);
	 newXS("RNA::b2C", _wrap_b2C, file);
	 newXS("RNA::b2Shapiro", _wrap_b2Shapiro, file);
	 newXS("RNA::add_root", _wrap_add_root, file);
	 newXS("RNA::expand_Shapiro", _wrap_expand_Shapiro, file);
	 newXS("RNA::expand_Full", _wrap_expand_Full, file);
	 newXS("RNA::unexpand_Full", _wrap_unexpand_Full, file);
	 newXS("RNA::unweight", _wrap_unweight, file);
	 newXS("RNA::unexpand_aligned_F", _wrap_unexpand_aligned_F, file);
	 newXS("RNA::parse_structure", _wrap_parse_structure, file);
	 newXS("RNA::make_tree", _wrap_make_tree, file);
	 newXS("RNA::tree_edit_distance", _wrap_tree_edit_distance, file);
	 newXS("RNA::print_tree", _wrap_print_tree, file);
	 newXS("RNA::free_tree", _wrap_free_tree, file);
	 newXS("RNA::Make_swString", _wrap_Make_swString, file);
	 newXS("RNA::string_edit_distance", _wrap_string_edit_distance, file);
	 newXS("RNA::Make_bp_profile", _wrap_Make_bp_profile, file);
	 newXS("RNA::profile_edit_distance", _wrap_profile_edit_distance, file);
	 newXS("RNA::print_bppm", _wrap_print_bppm, file);
	 newXS("RNA::free_profile", _wrap_free_profile, file);
	 newXS("RNA::space", _wrap_space, file);
	 newXS("RNA::nrerror", _wrap_nrerror, file);
	 newXS("RNA::init_rand", _wrap_init_rand, file);
	 newXS("RNA::urn", _wrap_urn, file);
	 newXS("RNA::int_urn", _wrap_int_urn, file);
	 newXS("RNA::filecopy", _wrap_filecopy, file);
	 newXS("RNA::time_stamp", _wrap_time_stamp, file);
	 newXS("RNA::random_string", _wrap_random_string, file);
	 newXS("RNA::hamming", _wrap_hamming, file);
	 newXS("RNA::get_line", _wrap_get_line, file);
	 newXS("RNA::pack_structure", _wrap_pack_structure, file);
	 newXS("RNA::unpack_structure", _wrap_unpack_structure, file);
	 newXS("RNA::make_pair_table", _wrap_make_pair_table, file);
	 newXS("RNA::bp_distance", _wrap_bp_distance, file);
	 newXS("RNA::PS_rna_plot", _wrap_PS_rna_plot, file);
	 newXS("RNA::gmlRNA", _wrap_gmlRNA, file);
	 newXS("RNA::ssv_rna_plot", _wrap_ssv_rna_plot, file);
	 newXS("RNA::xrna_plot", _wrap_xrna_plot, file);
	 newXS("RNA::PS_dot_plot", _wrap_PS_dot_plot, file);
	 newXS("RNA::read_parameter_file", _wrap_read_parameter_file, file);
	 newXS("RNA::write_parameter_file", _wrap_write_parameter_file, file);
	 newXS("RNA::ptrcast", _wrap_ptrcast, file);
	 newXS("RNA::ptrvalue", _wrap_ptrvalue, file);
	 newXS("RNA::ptrset", _wrap_ptrset, file);
	 newXS("RNA::ptrcreate", _wrap_ptrcreate, file);
	 newXS("RNA::ptrfree", _wrap_ptrfree, file);
	 newXS("RNA::ptradd", _wrap_ptradd, file);
	 newXS("RNA::ptrmap", _wrap_ptrmap, file);
	 newXS("RNA::deref_any", _wrap_deref_any, file);
	 newXS("RNA::ptr2array", _wrap_ptr2array, file);
	 newXS("RNA::make_loop_index", _wrap_make_loop_index, file);
	 newXS("RNA::energy_of_move", _wrap_energy_of_move, file);

/* work around segfault when script tries to free symbolset */

symbolset = (char *) space(21);
strcpy(symbolset, "AUGC");

	 newXS("RNA::bond_i_set", _wrap_bond_i_set, file);
	 newXS("RNA::bond_i_get", _wrap_bond_i_get, file);
	 newXS("RNA::bond_j_set", _wrap_bond_j_set, file);
	 newXS("RNA::bond_j_get", _wrap_bond_j_get, file);
{
   int i;
   for (i = 0; _swig_mapping[i].n1; i++)
        SWIG_RegisterMapping(_swig_mapping[i].n1,_swig_mapping[i].n2,_swig_mapping[i].pcnv);
}
	 ST(0) = &PL_sv_yes;
	 XSRETURN(1);
}
